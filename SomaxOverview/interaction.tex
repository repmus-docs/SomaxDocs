When interacting with Somax, there are three main concepts that are important to understand: «slices», «influences» and «peaks». A slice, as previously mentioned, is a short segment of the corpus and serves as the smallest building block of the output of the system. The slice can be manipulated to some extent (transposed, filtered with regards to voices/channels, etc.) but will always maintain most fundamental properties of the original corpus. 

An «influence» is in a way conceptually very similar to a slice, but with a vastly different purpose. When Somax listens to a musician, this musical stream is segmented and analyzed with respect to its musical parameters similarly to how the corpus was constructed, but with a slightly different set of methods to be able to operate in real-time. The result of this process are discrete chunks of multilayer data or «influences», which the system uses to be able to compare the input to the corpus, where the main purpose of the influence is to act as the guide that determines the output of the system. The concept of an influence may initially seem like an implementation detail, but will become increasingly important for more complex configurations with multiple agents and/or multiple input sources. The main takeaway is that the system cannot listen directly to a musical input stream, but will need to translate it into influences, and that the process of tuning the listener can be a very important factor for the quality of the co-improvisation.

Finally, a «peak» is, again, a point in the corpus where the input corresponds to the model, or simply a match between an incoming influence and a corresponding slice that would serve as an output candidate. Each peak has a height, corresponding to a probability (or viability) of that particular slice as an output candidate. Unlike influences (which are visible in the interface) and slices (which are correlated to the audible output of the system), peaks are never interacted with directly, they're only part of the internal state of the system, but perhaps the most vital part. Each peak effectively corresponds to a slice in the corpus that could serve as an output at the current point in time, given the latest influence. Having a reasonable number of peaks is thus vital for the quality of the output, since having no peaks means that the output has not taken the musician's influences into account, and on the opposite side, in most cases a large number of peaks indicate that the matching is imprecise. 

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.45\textwidth]{img/peaks_ui.png}
    \caption{While the user doesn't interact directly with the peaks, they are still indicated in the user interface.    Here, the colors green, red, blue and white correspond to the number of peaks in the feedback layer (more on this later), pitch layer, harmonic layer and total number of peaks after merge respectively.}
\end{figure}

To put the concept of peaks in context, let's dive a bit deeper in how the system works. While the musician is playing, Somax is at each detected onset segmenting the input into influences, carrying information about the pitch, harmony, etc. of what the musician currently is playing. This process is carried out by agents of the system called «influencers». This information is routed to a «player», which handles the entire process of matching and generating output. The influence is classified in multiple layers by the player, as briefly mentioned, where each layer corresponds to one musical dimension (e.g. harmony, melody) of the influence. In each layer, a model of the corpus with respect to the particular layer's musical dimension exists, and upon receiving an influence, the model will look for sequences in the corpus that match the sequence of most recent influences from the input, and in each of those places generate peaks. 

 \begin{figure}[h]
    \centering        
 	\includegraphics[width=0.99\textwidth]{img/peaks_decay.png}
    \caption{The process of shifting and decaying previous peaks in a single layer upon receiving new influences (the process of matching the incoming influence to the corpus has been omitted for clarity).}
    \label{fig:peakdecay}
\end{figure}

The system is also simulating a type of short-term memory inside this model by not immediately discarding peaks from previous influences, but rather shifting them along the time axis of the corpus and decaying their height corresponding to the amount of time that has passed, followed by merging them with the new set of peaks. This means that sequences continuously matching several consecutive influences will be more highly prioritized over others, as is illustrated in figure \ref{fig:peakdecay}. Finally, the peaks from all layers will be merged together into a single set of peaks which the system will use to probabilistically determine which slice is the best output candidate\footnote{actually, in addition to this, there are a number of parameters that scale the height of the peaks individually with regard to a number of other musical parameters of choice, but this is thoroughly documented in the help files in max and will not be discussed here}. The result of this multilayer peak merging process is an output that will not just strictly match the harmony and pitch of the influence but rather improvise around the most recent history of influences with regards to the corpus, often (depending on how the parameters tuned) selecting peaks matching both the harmony and/or melody of the input but with an ability and agency to act more freely with regards to its history. In addition, there's also a layer which listens to the output of the system, a feedback layer, that can be used to balance the player's consistency with the input with its continuity with its own performance. The balance between the different layers as well as control over the decay time of old peaks, length of sequences to match in the memories, etc. are all available in the user interface as displayed in figure \ref{fig:atomui}. 

 \begin{figure}[h]
    \centering        
 	\includegraphics[width=0.33\textwidth]{img/atoms_ui.png}
    \caption{User interface to control the balance between the dimensions, length of matching sequences for each dimension as well as decay time of peaks.}
    \label{fig:atomui}
\end{figure}

 \begin{figure}[h]
    \centering        
 	\includegraphics[width=0.68\textwidth]{img/peaks_merge.png}
    \caption{Three layers of peaks corresponding to different musical dimensions such as pitch, harmony, feedback, etc., being merged into one set of peaks before the final scaling and peak selection. Here, all three layers are weighted equally, but it is possible to balance the contribution from each of the layers.}
    \label{fig:peakmerge}
\end{figure}

If the concept of peaks isn't perfectly clear to you after reading this – don't worry! Go to the tutorial and start experimenting with the system while keeping one thing in mind: if the number of peaks is continuously zero or continuously too high\footnote{exactly how large "too high" is varies with the type of layer and context, but larger than 10\% of the total number of slices in the corpus with no transpositions active could serve as a reference of "too high" that is valid for most layers and contexts}, this is likely an indicator that the system is working poorly and should be retuned. If not – you're probably doing quite well.

Another important aspect of the interaction with Somax is its relation to time. According to the user's preference, each player can be assigned to either operate continuously in time as an autonomous agent, maintaining the pulse and exact within-slice timings of the original corpus (while possibly adapting to the tempo and/or phase of the input), or operate reactively, generating output synchronously as requested by the input. In the continuous case, this means that the player improvises freely over time while still taking the influences of the musician into account, while in the reactive case, it synchronizes strictly (note-by-note) with the input. Of course, the player is in the latter mode not strictly limited to the input from where it receives its influences, but could be connected to a third source of some sort, for example any type of step-sequencer or other generative approaches, thus giving the user multiple options for controlling the temporal domain of the system.