\chapter{The Python Architecture}\label{sec:2-python-architecture}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OVERVIEW 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}\label{ssec:2-overview}
The Python code base is the back-end of Somax and contains all of the generative aspects of the system, including modelling and classification, the implementation of the corpus and associated descriptors, scheduling and temporal behaviours, etc. The Python code base interacts with the Max front-end through OSC, where the Max front-end mainly handles real-time audio analysis and rendering, along with relevant visualization, as well as providing the user with an interface and/or GUI for interaction, but everything else is handled in Python.

A class diagram for the entire Python architecture is available in appendix \ref{sec:a-class-diagram}, and parts of this class diagram will be used throughout this chapter to illustrate certain parts of the architecture.

This chapter is divided into a number of sections, each outlining different aspects of the software architecture. Section \ref{ssec:2-io-parsing} describes the entry points into the application and how the OSC communication and interaction between the core elements work, section \ref{ssec:2-corpus} explains the architecture of the corpus, section \ref{ssec:2-scheduling} explains all aspects of the back-end related to time and scheduling, section \ref{ssec:2-player} describes the architecture of the \texttt{Player}, i.e. the class that is responsible for the modelling of the corpus and matching influences, and finally section \ref{ssec:2-compilation} will describe the current procedure of compiling the Python code into a standalone application for distribution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Associated Libraries}\label{ssec:2-librarybranches}
In addition to standard dependencies (such as Librosa, Numpy, Scipy, etc., see \texttt{python/somax/requirements.txt} for a full list), there are two external libraries that were developed within the team specifically for the needs of Somax and its related DICY2 library \cite{nika2016thesis}, \cite{nika2022dicy2}. These are the MaxOSC library \cite{maxoscrepo} and the GIG library \cite{gigrepo}. 



\subsubsection{The MaxOSC Library}\label{ssec:2-maxosc}

The MaxOSC library was developed early in the 2.0 beta phase of Somax with the intention of facilitating OSC communication between Max and Python. It contains a number of classes for exposing a Python class' member functions so that they are directly callable over OSC using a Python-like syntax, as well as adding support for more complex types than the ones supported by the OSC protocol \cite{osc2022} (such as nested lists, hash maps, etc.)

The MaxOSC library was initially developed as two sister libraries: MaxOSC, the Python library described above, and PyOSC, a set of Max objects for facilitating the interaction in Max.\footnote{Note that the name of the python repository is \texttt{pyosc} for this reason, but only the subfolder \texttt{maxosc} is currently used in Somax} The latter was revisited during the work on the \cite{gigrepo} (described below) and new externals for synchronous as well as asynchronous OSC calls to a remote, hierarchical class architecture\footnote{See the \texttt{dev-connector-singleton} branch of the \texttt{pyosc} repository}, were developed, but ultimately not used in the current version of as the development of Somax took a different turn when the development of DICY2 ceased. The MaxOSC library is available on PyPI and can be installed directly through \text{pip}.


\subsubsection{The GIG Library}\label{ssec:2-gig}

The GIG library \cite{gigrepo} was developed in 2022 with two goals in mind. Firstly, to provide a unified architecture for Somax and DICY2 so that research and improvements in either of the two would benefit the other, as well as ideally merge the two into a single framework of generative agents. Secondly, to use our experiences of working with the libraries to unify and solve a number of architectural issues with the current implementations, as well as to  generalize a number of functionalities (such as OSC parsing, scheduling, classification, corpus building, etc.) and thereby provide easy-to-use classes that could be used in future projects. 

Ultimately, the GIG library was not put to use in Somax as it was abandoned when the DICY2 development came to a halt, but it is referenced frequently in this report, as it provides solutions to a number of problems that still exist in the current code base of Somax, and could be used as a future reference. The rewritten version of Somax, based on the GIG library, is available on the \texttt{dev-merge-osc} branch of the Somax2 repository.

The GIG library is currently not available on PyPI, but it can be imported as a git submodule. See the \texttt{Dicy2-python} repository \cite{dicy2pythonrepo} for reference on how to use it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% INPUT/OUTPUT & PARSING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Input/Output \& Parsing}\label{ssec:2-io-parsing}
When using Somax with the Max front-end, the \texttt{somax\_server.py} file contains the \texttt{main} function, and once launched, any other communication will be handled solely through OSC. The \texttt{main} function instantiates the \texttt{SomaxServer} class, which corresponds to the \texttt{somax.server} object in Max (see section \ref{ssec:3-server}).

The \texttt{SomaxServer}'s main role is to manage the application's \texttt{OscAgent}s, where each \texttt{OscAgent} corresponds to a \texttt{somax.player} object (see section \ref{ssec:3-player}). It's also responsible for the \texttt{Transport} object, which is the clock that synchronizes time between all the different players (this will be further described in section \ref{ssec:2-scheduling}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{AsyncioOscObject}

Both the \texttt{SomaxServer} and \texttt{OscAgent} inherit from the \texttt{AsyncioOscObject}, which is the class responsible for all OSC handling. This class uses an \texttt{asyncio}-based \cite{pyasyncio2021} UDP server for handling messages sent from the Max front-end, which means that it's able to have zero or more runtime callbacks that are processed in parallel with OSC I/O operations. Note that while \texttt{asyncio} in some sense allows us to write concurrent code, it's still effectively single-threaded, so there's no need to worry about race conditions, data races or other parallelism-related issues. This applies to all of the Somax library: while it relies on several parallelism-oriented libraries (both multiprocessing \cite{pymultiproc2021} and asyncio), it's designed so that no resources ever are shared and each component of the system can always be treated as if it was single-threaded.

The \texttt{AsyncioOscObject} inherits from the \texttt{Caller} class of the \texttt{maxosc} package, which automatically exposes all function of the class (and any class inheriting from it) so that it can be called directly over OSC using a python-like syntax. For example, a function like

\begin{lstlisting}
def create_agent(self, 
                 name: str,
                 recv_port: int, 
                 send_port: int,
                 ip: str = "",
                 override: bool = False)
\end{lstlisting}
can be called over OSC using any of the following messages

\begin{lstlisting}
/somax create_agent "Player1" 1234 1235 "127.0.0.1" 1
/somax create_agent name= "Player1" recv_port= 1234 send_port= 1235 override= 1
/somax create_agent name="Player1" recv_port=1234 send_port=1235 override=True
/somax create_agent "Player1" 1234 1235 override= 1
\end{lstlisting}
In other words, the syntax is similar to how a Python function normally is called but adapted to a Max environment (using spaces rather than commas, allowing spaces between argument names and values, e.g. \texttt{recv\_port= 1234} rather than \texttt{recv\_port=1234}, to avoid having to use the \texttt{combine} object in Max for named arguments, etc.) It's also possible to pass nested lists and/or dictionaries from Max with a Python-like syntax. e.g. for some Python function \texttt{f} that accepts nested lists, any of the following calls from max would be valid:

\begin{lstlisting}
	/somax f []
	/somax f [ 1 2 3 4 ]
	/somax f [1 2 3 4]
	/somax f [ [1 2] [3 4] [ 5 6 ]]
\end{lstlisting}
Note that the OSC address is not used at all (it's \texttt{/somax} for all calls to the \texttt{SomaxServer} and the name of the agent for any call to a \texttt{OscAgent}, but both of these are redundant as each server and agent uses its own set of ports). This is because the underlying \texttt{python-osc} library does not support adding OSC addresses dynamically through OSC calls (e.g. if we want to create an agent \texttt{agent1} at address \texttt{/somax/agent1} through the \texttt{create\_agent} function called over OSC, this will simply not work using the \texttt{python-osc} library).

The \texttt{\_main\_loop} function is the only abstract function of the \texttt{AsyncioOscObject}. In the \texttt{SomaxServer}, this is implemented as a dynamic variable \texttt{self.loop}, which is bound either to the \texttt{\_\_master\_loop} or \texttt{\_\_slave\_loop} functions. At the moment, only the \texttt{\_\_master\_loop} is used, but the \texttt{\_\_slave\_loop} function was added in order to allow synchronizing the transport of the \texttt{SomaxServer} to an external clock, for example the Live transport (if using Somax in Max for Live device) or a transport in Somax. This is however not exposed in the front-end (i.e. the Max \texttt{somax.server} object) at the moment.

Also note that an improved version of the \texttt{AsyncioOscObject} exists in the GIG library (there called \texttt{AsyncOsc}), which has a number of subclasses for handling different types of async OSC communication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{SomaxServer \& OscAgent}\label{ssec:2-server-agent}
The central class of the Somax library is the \texttt{OscAgent}, which, as mentioned above, corresponds to the \texttt{somax.player} object. The \texttt{OscAgent} is initialized through the \texttt{SomaxServer}, but once initialized, the \texttt{somax.player} and \texttt{OscAgent} communicate directly through their own set of OSC ports. This class is responsible for handling all input/output to the \texttt{Player} (such as influences, output requests, setting parameters, etc.), as well as the co-ordinating time management between the \texttt{SomaxServer} and the \texttt{Player}, which is managed through the \texttt{SchedulingHandler}.

The \texttt{OscAgent} inherits from \texttt{multiprocessing.Process} class, which essentially is a way to bypass the global interpreter lock (GIL) in Python by running each \texttt{OscAgent} in its own subprocess rather than its own thread. Communication between the \texttt{OscAgent} and \texttt{SomaxServer} is handled through a \texttt{multiprocessing.Queue}, essentially a two-way pipe which passes \texttt{ProcessMessage}s between the two objects. Almost all of the communication are messages related to time and scheduling and will be described in section \ref{ssec:2-scheduling}\footnote{The only exceptions are the \texttt{PlayControl.CLEAR} and \texttt{PlayControl.TERMINATE} messages of the \texttt{ControlMessage} class, which calls \texttt{OscAgent.clear()} and \texttt{OscAgent.terminate()} functions accordingly.}.

The \texttt{SomaxServer} owns the \texttt{OscAgent}s and is responsible for joining their processes once finished (e.g. when the server is shut down or if the \texttt{somax.player} is deleted in Max). In addition, the \texttt{SomaxServer} is also managing the \texttt{CorpusBuilder}s, which will be launched as separate \texttt{multiprocessing.Process}es when the user is building a corpus (in order to not block the \texttt{Transport} while building corpora). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The Target class}\label{ssec:2-target-class}

Any output from the \texttt{OscAgent} and \texttt{SomaxServer} classes (i.e. messages to the front-end) are sent through the \texttt{Target} class, which is a light wrapper around the \texttt{pythonosc} UDP client (with some formatting for Max compatibility). In other words, all OSC communication is handled by the \texttt{OscAgent} and \texttt{SomaxServer} classes, so these are the only two classes one needs to understand to fully understand all supported IO operations\footnote{There's one slight exception to this rule: the \texttt{ThreadedCorpusBuilder}. Once the process of building a corpus through the \texttt{ThreadedCorpusBuilder} has been launched, it does not communicate with the \texttt{SomaxServer}, but its return value, which is either the path of the built corpus or an error message, is sent through its own \texttt{Target}, which however is using the same ports as the \texttt{SomaxServer} and hence received directly by the \texttt{somax.server}'s \texttt{udpreceive} object.}. 

The \texttt{Target} will, just like the \texttt{AsyncioOscObject} return messages to a the same static OSC addresses mentioned above, and rather use a keyword for the OSC messages to the Max front-end (which is the common practice in Max). All of the keywords for the OSC messages sent from the \texttt{SomaxServer} and \texttt{OscAgent} are stored in the \texttt{ServerSendProtocol} and \texttt{PlayerSendProtocol} respectively. In other words, the entire protocol for OSC messages sent from the back-end to the front-end can be understood by reading through these two classes.\footnote{Similarly, the entire protocol for OSC messages from the front-end to the back-end can be understood by reading the function signatures of the \texttt{SomaxServer} and \texttt{OscAgent} classes.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parsing \& Exception Handling}\label{ssec:2-parsing-introspective}
As the \texttt{SomaxServer} and \texttt{OscAgent} classes are handling all I/O operations, they are also responsible for parsing the messages and ensuring that no invalid messages are accepted. 

The Somax Python library relies heavily on type annotations, and will generally not check whether the correct type is passed; this is rather left to the developer/user to handle ("We're all consenting adults here", as the Python mantra goes). The one exception to this rule are the \texttt{SomaxServer} and \texttt{OscAgent} classes, as these handle input directly from a user in Max (through the \texttt{somax.server} and \texttt{somax.player} objects), who we cannot assume is necessarily passing the correct information, and who will need proper error messages posted in the Max console, rather than cryptic Python exceptions, when the wrong type of information is sent. Therefore, the \texttt{SomaxServer} and \texttt{OscAgent} have very strict type and bounds checking.

A number of functions in the \texttt{OscAgent} also makes frequent use of the fact that introspection is possible in Python. As many components of the Somax architecture are modular (\texttt{AbstractScaleAction}, \texttt{AbstractClassifier}, \texttt{AbstractActivityPattern}, etc.), Any class whose base class is inheriting from the \texttt{StringParsed} class can be parsed directly from a string corresponding to the class' name, assuming that they are located in the same module. For example

\begin{lstlisting}
>>> AbstractScaleAction.from_string("nextstatescaleaction")
<somax.runtime.scale_actions.NextStateScaleAction object at 0x..>
\end{lstlisting}
This means that new classes can be added in the same module and be fully accessible through the OSC protocol without changing any part of the code related to the parsing. The only exception to this strategy is the \texttt{FeatureValue} class, where new features need to be added to the \texttt{somax/features/\_\_init\_\_.py}, as the classes to parse are spread over several modules.

Finally, it's worth noting that the \texttt{SomaxServer} is actually split in two classes: \texttt{Somax} and \texttt{SomaxServer}, and similarly the \texttt{OscAgent} in \texttt{Agent} and \texttt{OscAgent}. The intention with this distinction was to separate the parsing/OSC handling into a separate class, so that the \texttt{Agent} and \texttt{Somax} classes could be used directly in Python. The current separation is however not used and largely irrelevant â€” a proper and clean separation of the two can instead be found in the (abandoned) \texttt{dev-merge-osc} branch.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parametric \& Parameter}\label{ssec:2-parameters}
The final aspect of the I/O and parsing is the \texttt{Parametric} class. Since the configuration of the \texttt{Player} can change dynamically by adding/removing \texttt{Atom}s, \texttt{ScaleAction}s, etc. it's necessary to be able to address parameters of said classes dynamically so that they can be changed from the front-end. This is handled by the \texttt{Parametric} and \texttt{Parameter} classes. The relationship between the two can be seen as a tree where \texttt{Parametric} are the branch nodes and \texttt{Parameter} are the leaf nodes, where the value of a \texttt{Parameter} can be set by addressing its position in the tree. For example, given a \texttt{Parameter} \texttt{ngram\_length} of the \texttt{NGramMemorySpace} (which inherits from the \texttt{Parametric} class, where the latter is owned by an \texttt{Atom} of the player (also inheriting from the \texttt{Parametric} with the name \texttt{melodic}, the value of this parameter can be set by calling the \texttt{Player}'s \texttt{set\_param} function:
\begin{lstlisting}
/agent1 set_param melodic::_memory_space::_ngram_size 3
\end{lstlisting}
Note that the parameter tree needs to be re-computed when any \texttt{Parametric} (for example a \texttt{ScaleAction}) is added or removed. This is done through the \\ \texttt{Parametric.parse\_parameters} function.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% THE CORPUS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Corpus}\label{ssec:2-corpus}
The \texttt{Corpus} class is the material from which the \texttt{Player} generates all its content. A corpus is constructed by passing an audio file or one or multiple MIDI files to the \texttt{CorpusBuilder}'s \texttt{build} function, which will segment the file and attempt to analyze its with respect to all applicable \texttt{CorpusFeature}s. If an analysis fails (for example if the \texttt{CorpusFeature} only is designed for MIDI), it will simply ignore the given feature and move on to the next one. Understanding the procedure of building the \texttt{Corpus} shouldn't pose any problem for a developer with some experience in Python. It's also possible to build a \texttt{Corpus} by providing your own analysis to the \texttt{ManualCorpusBuilder}, which will read the analysis from a text file, see comments in the code for more info.

The \texttt{CorpusBuilder.build} will return an \texttt{AudioCorpus} or \texttt{MidiCorpus} depending on the type provided, which, when built through the \texttt{SomaxServer}, will be exported as a file. An \texttt{AudioCorpus} is exported as a \texttt{.pickle} file, while a \texttt{MidiCorpus} is exported as a gzip'ed json. Note that exporting a pickle is a far superior approach in terms of performance and file size, and the only reason why the \texttt{MidiCorpus} isn't using this format is because it hasn't been updated from its legacy json format yet.

The \texttt{Corpus} itself can be either a \texttt{AudioCorpus}, consisting of a list of \texttt{AudioCorpusEvent}s, or a \texttt{MidiCorpus}, consisting of a list of \texttt{MidiCorpusEvent}s, which in turn contains a list of \texttt{Notes}. In the \texttt{AudioCorpus}, each even corresponds to a segment of the audio as determined by the onset segmentation as computed by the \texttt{AudioCorpusBuilder}. In the \texttt{MidiCorpus}, each event corresponds to all the MIDI data between two note ons\footnote{The MIDI segmentation process is described in \cite{somaxtheory2021}.}, where the \texttt{Note.\_onset} and \texttt{Note.\_duration} attributes are stored relative to their parent \texttt{MidiCorpusEvent} (in other words, a note can have an onset of -2.5, meaning that it starts 2.5 quarter notes before the start of the given event, and therefore is held at the start of the given event). A number of convenient functions exist in the \texttt{MidiCorpusEvent} to get all the notes that starts/ends before/at/within the given event.

\subsection{Features}\label{ssec:2-features}
Each \texttt{CorpusEvent} has a dictionary of \texttt{FeatureValue}s (stored by type, e.g. \\\texttt{my\_corpus.get\_feature(MeanChroma)} will return the value of its \texttt{MeanChroma}) that was analyzed when the \texttt{Corpus} was built. There's currently a separation between \texttt{CorpusValue} and \texttt{CorpusFeature}, where the former only contains the actual value while the latter also includes the procedure to compute it from a list of \texttt{CorpusEvent}s (\texttt{CorpusFeature.analyze}).\footnote{This separation was made to avoid a circular dependency between the \texttt{CorpusEvent} and the \texttt{CorpusFeature}, but a better solution to the problem is available in the \texttt{dev-merge-osc} branch.}

The \texttt{CorpusBuilder} relies on the procedure described in section \ref{ssec:2-parsing-introspective} for parsing all implemented \texttt{CorpusFeature}s for analysis. As the \texttt{CorpusFeature}s are split into separate modules, it's however necessary to import them in the \texttt{features/\_\_init\_\_.py} module to expose them to the automated parsing. So, in order to implement new \texttt{Features}:

\begin{itemize}
	\item Implement the feature by inheriting from \texttt{CorpusFeature} (make sure to also inherit from \texttt{RuntimeFeature} to make it runtime parsable as an \texttt{FeatureInfluence}, if applicable) and implement its abstract methods
	\item If the feature is MIDI only or audio only, make sure to raise a \texttt{FeatureError} if it receives the wrong type of data. In this case, it will simply be ignored
	\item Import the feature in \texttt{features/\_\_init\_\_.py}
\end{itemize}
The next time a \texttt{CorpusBuilder} builds a new \texttt{Corpus}, the new feature will be available through \texttt{Corpus.get\_feature}.

Note that when new features are added and the Somax library is extended with new functionalities relying on these new features, this might mean that corpora built in earlier versions of Somax may no longer work correctly. When loading a \texttt{Corpus}, from a file, the \texttt{Corpus.from\_json} function uses the utility class \texttt{VersionTools} to check the version of the \texttt{Corpus} loaded corpus, and if it doesn't match the current version, it will print an explicit error. So if a new feature is added with the intention of being a mandatory part of any \texttt{Corpus}, the corpus version number, stored in the field \texttt{\_\_version\_corpus\_\_} in \texttt{somax/\_\_init\_\_.py} should be incremented. 

If the new features is optional, an alternative is to use the \texttt{ContentAware} class (described in section \ref{ssec:2-content-aware}) to disable parts of the code that rely on the given feature.

\subsection{ContentAware \& Eligibility}\label{ssec:2-content-aware}
In some cases, a feature may only be defined for a certain type of corpus. For example, the \texttt{VerticalDensity} feature, which corresponds to the number of MIDI notes in the given event, is undefined for an audio corpus. To still be able to use these types of features in the \texttt{Player} without crashing if a corpus of the wrong type is loaded, the \texttt{ContentAware} interface was implemented. Any class inheriting from the \texttt{ContentAware} interface will simply be bypassed when a corpus is loaded if \texttt{ContentAware.\_is\_eligible\_for} returns \texttt{False}. In practice, this is only used in a few experimental classes of the \texttt{Player}, such as \texttt{VerticalDensityScaleAction}, \texttt{OctaveBandsScaleAction}, etc. Refer to these for more info.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SCHEDULING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Scheduling}\label{ssec:2-scheduling}
One of the most important responsibilities of the Python back-end is to manage time and scheduling. The current time, represented by a \texttt{Time} object, is managed by the \texttt{Transport} in the \texttt{SomaxServer}, and is synchronized between all \texttt{OscAgent}s. The \texttt{Transport} is polled each millisecond in the \texttt{SomaxServer.callback()} function to update the \texttt{Time}, and then sends it to each existing \texttt{OscAgent} through its associated \texttt{multiprocessing.Queue} (see section \ref{ssec:2-server-agent}). The \texttt{OscAgent} has its own \texttt{\_main\_loop} function where it receives these messages and updates time accordingly through its \texttt{Scheduler}. The current time is through the \texttt{Time} object represented both in ticks (where 1.0 ticks corresponds to one quarter note) and seconds, and has an associated tempo.

The \texttt{Transport} and \texttt{Scheduler} manage two different responsibilities: the \texttt{Transport} is the internal clock of the system, which manages how much time has elapsed since the previous callback, while the \texttt{Scheduler} is responsible for when each event should happen.

The \texttt{OscAgent} does not communicate directly with the \texttt{Scheduler}; the \texttt{OscAgent} has a \texttt{SchedulingHandler}, which has a \texttt{Scheduler}. The \texttt{SchedulingHandler} is an abstract base class with a number of different implementations, where the different implementations roughly corresponding to the \texttt{mode} attribute in the \texttt{somax.player} object, and is described in section \ref{ssec:2-scheduling-handler}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{ScheduledEvent}\label{ssec:2-scheduled-event}
The \texttt{Scheduler} only accepts a single type of message: the abstract \texttt{ScheduledEvent} class, which has a \texttt{trigger\_time}, which determines when the event should be output by the \texttt{Scheduler}. There are four main types of \texttt{ScheduledEvent}s:

\begin{description}
	\item[\texttt{TriggerEvent}] When output, triggers output by the \texttt{Player} through the \\\texttt{OscAgent.\_trigger\_output} function.
	\item[\texttt{RendererEvent}] Contains OSC messages that will be sent directly to Max to trigger rendering of some sort (example subclasses are \texttt{MidiNoteEvent}, \texttt{AudioEvent}, \texttt{AudioOffEvent}, etc.)
	\item[\texttt{TempoEvent}] Contains information about the last played \texttt{CorpusEvent}s annotated tempo. If the \texttt{OscAgent} is set as the \texttt{SomaxServer}'As tempo source, it will send this message through the \texttt{multiprocessing.Queue} back to the server to set its tempo. If not, it will simply be ignored
	\item[\texttt{ContinueEvent}] When output, triggers output by the \texttt{Player} through the \\ \texttt{OscAgent.\_continue\_output} function. The difference between \texttt{TriggerEvent} and \texttt{ContinueEvent} is described in section \ref{ssec:2-timeout}.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The SchedulingHandler}\label{ssec:2-scheduling-handler}
The \texttt{SchedulingHandler}'s main role is to receive \texttt{CorpusEvent}s, convert them into the appropriate \texttt{ScheduledEvent}s and schedule them accordingly through its internal \texttt{Scheduler}, which is handled by the \texttt{SchedulingHandler.add\_corpus\_event} function. When triggering output from a \texttt{somax.player} object in Max (e.g. through a \texttt{bang} or a \texttt{influence onset} message, which both call the \texttt{OscAgent.bang} function), this does not directly trigger output but rather schedules a \texttt{TriggerEvent} through the \texttt{SchedulingHandler.add\_trigger\_event} function. There are currently three different \texttt{SchedulingHandler}s with three different behaviours for \texttt{add\_corpus\_event} and \texttt{add\_trigger\_event}:

\begin{description}
	\item[AutomaticSchedulingHandler] Plays continuously by immediately scheduling a new \texttt{TriggerEvent} at the end of each \texttt{CorpusEvent} received. Any manual triggers called through the \texttt{add\_trigger\_event} will be ignored. This class corresponds to \texttt{@mode continuous} in the Max front-end.
	\item[ManualSchedulingHandler] Schedules a single \texttt{TriggerEvent} immediately when the \texttt{add\_trigger\_event} is called, thereby interrupting any currently rendered events. Does not reschedule any \texttt{TriggerEvent}s on \texttt{add\_corpus\_event}. This class corresponds to \texttt{@mode reactive} with \texttt{@cut 1} in the Max front-end.
	\item[IndirectSchedulingHandler] Schedules a single \texttt{TriggerEvent} immediately when the \texttt{add\_trigger\_event} is called, unless it is in the middle of rendering an event, in which case it will schedule the trigger at the end of the current event. This class corresponds to \texttt{@mode reactive} with \texttt{@cut 0} in the Max front-end.
\end{description}
Note that while neither the \texttt{ManualSchedulingHandler} nor the \\ \texttt{IndirectSchedulingHandler} will ever reschedule any triggers, they may still continue playing further events due to the \texttt{ContinueEvent}. These behaviours are explained in section \ref{ssec:2-timeout}.

The process of converting an \texttt{CorpusEvent} into a set of \texttt{RendererEvent}s is handled by the \texttt{AudioStateHandler} (for an \texttt{AudioCorpusEvent}) and the \texttt{MidiStateHandler} (for a \texttt{MidiCorpusEvent}) classes. These classes are responsible for behaviours strictly related to the rendering, for example whether an audio renderer needs to jump in the buffer or may continue playing linearly, or in the MIDI case, to handle note offs, notes sustained over several slices, etc.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Synchronization \& Time Stretch}\label{ssec:2-time-stretch}

Due to the separation between time management (\texttt{Transport}) and scheduling \\ (\texttt{Scheduler}), time stretch is fairly simple to achieve, we can just apply a time stretch factor to the time received from the \texttt{Transport} and the scheduling will automatically adapt to the new, stretched tempo, assuming that we output the same information to the renderer. A naive approach would be
\begin{align}
	t_\text{stretch}[n] = t_\text{transport}[n] \cdot \gamma
\end{align}
where $n \in \mathbb Z_+$ indicate the current step in the callback, $t_\text{stretch}[n] \in \mathbb R_+$ the stretched time at step $n$, $t_\text{transport}[n] \in \mathbb R_+$ the \texttt{Transport}'s time at step $n$ and $\gamma \in \mathbb R_+$ is the time stretch factor (i.e. 1.0 means no time stretch, 0.5 half the speed, 2.0 double the speed, etc.). Since the user may change $\gamma$ over time, this would however produce discontinuities in time. To avoid this, we'll calculate the discrete integral over $t_\text{transport}$, i.e.
\begin{align}\label{eq:2-timestretch}
	t_\text{stretch}[n] = 	t_\text{stretch}[n-1]  + \left(t_\text{transport}[n] - t_\text{transport}[n-1]\right)\cdot \gamma[n]
\end{align}
where $\gamma[n]$ now indicates the current time stretch value set by the user at step $n$. 

All of this is handled in the \texttt{SchedulingHandler}, and the time stretch factor can be set with the \texttt{SchedulingHandler.set\_time\_stretch\_factor} function. There's however another way of achieving time stretch: by changing the server's (or more specifically, the \texttt{Transport}'s) tempo.

There are currently two modes for scheduling in Somax (super class \texttt{SchedulingMode}): 
\begin{description}
	\item[\texttt{RelativeScheduling}] events are scheduled in ticks,
	\item[\texttt{AbsoluteScheduling}] events are scheduled in seconds. 
\end{description}
In relative time, which is only used by MIDI corpora, changes to the server's tempo will naturally result in changes to the playback speed, as one tick corresponds to a quarter note, the duration (in seconds) of a tick changes with the tempo. In absolute time, changes to the tempo will not change the playback speed (a second is still a second). Audio corpora only have absolute time, but may still adapt to the tempo of the server by computing the difference between its annotated tempo and the server's tempo, and adjusting the time stretch factor accordingly. The choice between the different \texttt{SchedulingMode}s is not directly controlled by the user, but a result of whether the user chooses to synchronize to the server's tempo or to use a manual time stretch factor, as controlled by the \texttt{OscAgent.set\_synchronize\_to\_global\_tempo} function. In summary, we have four different cases:

\begin{description}
	\item[Audio corpus, synchronize=False] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ directly controlled by the user
	\item[Audio corpus, synchronize=True] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ calculated as the quotient between the server's tempo and the last rendered \texttt{AudioCorpusEvent}
	\item[MIDI corpus, synchronize=False] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ directly controlled by the user
	\item[MIDI corpus, synchronize=True] \texttt{RelativeScheduling} without any time stretch factor, directly adapting to the server's tempo.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Timeout \& ContinueEvent}\label{ssec:2-timeout}

One of the cornerstone of the Somax development process has been its modularity and encapsulation of functionality, meaning that in most cases, a certain behaviour or functionality, as controlled by the user, is limited to a single class and can therefore easily be understood by reading the code in that particular class. This approach also makes it simple to disable and/or modify the given behaviour, as the code that manages said behaviour self-contained and independent of other modules. 

There's however one exception to this development principle, and that is the concept which is called "timeout". The basis for this idea is simple: when we're in a mode where output is user-triggered (i.e. when using the \texttt{ManualSchedulingHandler} or the \texttt{IndirectSchedulingHandler}), we don't want the output to immediately stop once it has finished playing an event, but we want it to continue for some time after. 

In earlier versions of Somax ($\le$2.4.0), this behaviour was achieved (for audio corpora) by simply letting the renderer continue playing the buffer linearly for $N$ seconds after the last triggered event. While this solution was extremely simple, it came with a number of downsides: (i) there was no way to guarantee that the renderer wouldn't stop in the middle of an event, (ii) the user interface would not be able to indicate the currently played event during the timeout period\footnote{A few notes on the syntax used here: By "timeout", we're referring to the point in time when the player stops, after receiving no new triggers. The "timeout period" refers to the time after the end of the triggered event during which the player continuous to play one or multiple events that are not directly triggered by the user. In other words, the sequence is the following: trigger(user)$\rightarrow$event$\rightarrow$timeout period$\rightarrow$timeout.} and (iii) playing linearly is in many cases unsatisfactory in terms of creativity.

For this reason, a new timeout behaviour was conceived to solve the issues above, i.e. (i) timeout should never stop in the middle of an event, (ii) the user interface should indicate events played during the timeout phase and (iii) it should be possible to play events in a non-linear manner (i.e. by jumping/recombining) during the timeout phase. This was implemented by adding a separate \texttt{ScheduledEvent} called \texttt{ContinueEvent}, which triggers the \texttt{OscAgent.\_continue\_output} function (rather than the normal \texttt{OscAgent.\_trigger\_output}, which is described in section \ref{ssec:2-player}). 

Without prior knowledge, deciphering the exact control flow of the timeout behaviour throughout the many classes it applies to may be difficult, but the following summary should greatly simplify the procedure:

\begin{itemize}
	\item Timeout only applies when using \texttt{ManualSchedulingHandler} or \texttt{IndirectSchedulingHandler} 
	\item When \texttt{OscAgent.recombine=True}, \texttt{ContinueEvent}s will trigger \texttt{Player.new\_event}
	\item When \texttt{OscAgent.recombine=False}, \texttt{ContinueEvent}s will trigger \texttt{Player.step}
	\item During the timeout period, the \texttt{Player} will bypass the \texttt{sparse} option of the \texttt{FallbackPeakSelector} due to the \texttt{enforce\_output} parameter of the \texttt{Player.new\_event} function
	\item When switching to a \texttt{AutomaticSchedulingHandler}, any \texttt{TriggerEvent} will be converted to a \texttt{ContinueEvent} and vice versa
	\item When an event is triggered by the user, the timeout period starts over
\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% THE PLAYER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Player}\label{ssec:2-player}

The role of the \texttt{Player} class is to select the most appropriate \texttt{CorpusEvent} at each time step when generation is called for. The \texttt{Player} has been discussed extensively in \cite{somaxtheory2021} and \cite{somaxsoftware2021}, but a number of changes have been introduced since then. This section will give an overview of the main components and main functions of the \texttt{Player}.

The \texttt{Player} manages all of the modular components of the architecture that in turn determinate how the generation should work, and can be configured in a number of different ways (although only a single configuration is currently used in the \texttt{somax.player} object in Max). With few exceptions, the architecture of the \texttt{Player} is designed so that different behaviours are encapsulated in a single class, so that adding or removing a particular class will enable or disable a particular behaviour. These classes will be described in section \ref{ssec:2-player-classes}.

In practice, to understand the full behaviour of the \texttt{Player}, it's sufficient to understand its four main functions and the classes used for passing information between these functions. These functions will be described in section \ref{ssec:2-player-functions}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Main Classes}\label{ssec:2-player-classes}

The main classes managed by the \texttt{Player} are the \texttt{Atom}, \texttt{AbstractMergeAction}, \\\texttt{AbstractScaleAction}, \texttt{AbstractPeakSelector}, \texttt{FallbackSelector} and \\ \texttt{TransformHandler} classes.\footnote{In general, any class named \texttt{Abstract<ClassName>} is a modular component of Somax and has a number of implementations in the same module that represents a certain strategy for the part of the generation process that the base object corresponds to.}

Each \texttt{Atom} object corresponds to one layer of the generation, where each layer corresponds to one type of \texttt{Feature} of the \texttt{Corpus}. In the default \texttt{somax.player} configuration, these layers are \texttt{melodic}, which listens to pitch influences from Max, \texttt{harmonic}, which listens to chroma influences from Max, \texttt{self[melodic]} which through its \texttt{self\_influenced} parameter listens to pitch influences of the previously output \texttt{CorpusEvent} through the \texttt{Player.\_feedback} function (which will be discussed in section \ref{ssec:2-player-functions})  and \texttt{selfharmonic}, which listens to chroma influences of the previous output.

The \texttt{Atom} class manages three further objects: \texttt{Classifier}, \texttt{MemorySpace} and \texttt{ActivityPattern}. The \texttt{Classifier} is responsible for the strategy of analyzing incoming influences and converting them into discrete labels that the \texttt{MemorySpace} can use to discretely match the influences with the loaded \texttt{Corpus}, and the result is stored in the \texttt{ActivityPattern}, which is responsible for the state and peak-shifting strategy. All of this is thoroughly explained in \cite{somaxtheory2021}, but its the classes used for communication between the objects will be briefly discussed in section \ref{ssec:2-player-functions} in terms of classes.


In earlier reports (e.g. \cite{borg_2019}, \cite{somaxsoftware2021}), the \texttt{StreamView} class, an intermediate class between the \texttt{Player} and the \texttt{Atom}, was mentioned. Since Somax version 2.2, this class has been removed as it was never used in practice and added significant overhead in terms of performance. Now the \texttt{Player} directly manages all of its \texttt{Atom}s.

The \texttt{MergeAction} is responsible for combining all of the peaks from all \texttt{Atom}s when generating output through the \texttt{Player.new\_event} function (see \ref{ssec:2-player-functions}). Currently, only a single implementation of the \texttt{MergeAction} exists (\texttt{DistanceMergeAction}), which will merge peaks close to each other in time into a single peak. The algorithm is described in detail in chapter 4.2 in \cite{somaxtheory2021}. This procedure is necessary since the peaks are stored and shifted in continuous time, and we don't want all peaks throughout the entire duration of an event to be merged into a single peak, as this would introduce a strong bias towards longer events. But it's important to be aware of, as it is one of the most expensive operations of the runtime architecture of Somax.

In the previous theoretical report \cite{somaxtheory2021}, a distinction was made between merging peaks (chapter 4.2 in \cite{somaxtheory2021}) and scaling peaks (4.3 in \cite{somaxtheory2021}), but the software architecture did not portray this distinction, both of these roles were managed by the \texttt{MergeAction} class \cite{somaxsoftware2021}. This has since then been changed, the \texttt{MergeAction} only manages peak merging (as described in the previous paragraph), while a new class, the \texttt{ScaleAction} manages all aspects of conditional filtering and scaling of peaks. A \texttt{ScaleAction} may change the score of a certain peak based on how well it matches a condition (e.g. if it represents the next consecutive event in the \texttt{Corpus} or how well it matches some condition regarding the energy/amplitude/duration/etc. specified by the user), but it should never remove or add any peaks. Peaks with a score of 0 will however be removed once all \texttt{ScaleAction}s have been applied, so the implemented behaviour of any \texttt{ScaleAction}s should be commutative in order to ensure that peaks whose score is set to 0 by any \texttt{ScaleAction} remain at 0 so that they will be removed. In summary, one could say that the \texttt{Atom} is responsible for creating peaks based on a binary condition ("does it match or not?"), while the \texttt{ScaleAction} is responsible for weighting existing peaks based on how well they match certain conditions.

The \texttt{PeakSelector} is responsible for selecting a \texttt{CorpusEvent} to output, corresponding to one of the peaks it receives. If there are no peaks (either because all peaks were filtered out by the \texttt{ScaleAction}s or because no peaks existed in the \texttt{Atom}s in the first place), the \texttt{FallbackSelector} will be called to select a peak directly from the \texttt{Corpus}, if applicable.

Finally, the \texttt{TransformHandler} is responsible for managing \texttt{Transform}s (transpositions) in the architecture. When a \texttt{Transform} is added or removed by the user, this will trigger a number of behaviours in any aspect of the system related to matching (e.g. in the \texttt{NGramMemorySpace}, which keeps a history of the last $N$ matches for each transposition).

The \texttt{TransformHandler} is also responsible for converting a \texttt{Transform} into an index, so that it can be stored and used in an optimized way in a numpy \texttt{ndarray} in the \texttt{Peaks} class. Originally, when transforms were added to Somax (which dates back to the pre-2.0 beta versions developed by Axel Chemla--Romeu-Santos), it was envisioned that transpositions would just be one type of transform, and that many other options would be possible. For this reason, the \texttt{TransformHandler} stores each \texttt{Transform} by an index rather than an absolute value (e.g. a transform of +2 semitones is not necessarily stored as the value '2', but could be any value depending on the number of transforms that have been added or removed before the +2 transform was added). The theory and application of transforms are thoroughly described in chapter 5 in \cite{somaxtheory2021}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Main Functions}\label{ssec:2-player-functions}

The four main public functions of the \texttt{Player} are \texttt{Player.read\_corpus}, \texttt{Player.influence}, \texttt{Player.new\_event}, and \texttt{Player.step}. The reader should be able to gain a full understanding of the generative aspects of Somax by understanding those functions. In addition, the main classes used internally by these functions are the \texttt{AbstractInfluence}, \texttt{AbstractLabel} and \texttt{Peaks} classes.

\subsubsection{Player.read\_corpus}

\texttt{Player.read\_corpus} is called when a \texttt{Corpus} is loaded by the user, and will construct a model in each \texttt{Atom}'s \texttt{MemorySpace}, by in each \texttt{Atom} analyzing the \texttt{CorpusFeature} relevant for that particular layer in the \texttt{Classifier}, which converts the sequence of \texttt{CorpusFeature}s (one per \texttt{CorpusEvent} into a sequence of \texttt{Label}s, that the \texttt{MemorySpace} builds its model from.

\subsubsection{Player.influence}
The \texttt{Player.influence} is called each time the \texttt{OscAgent} receives a single influence from Max. When called, it updates the state of the targeted \texttt{Atom} (or more specifically the \texttt{Atom}'s \texttt{ActivityPattern}), where the \texttt{Peaks} are stored, but will not trigger any output.

When an \texttt{Atom} is influenced, it will first shift its stored \texttt{Peaks} based on the amount of (\texttt{Transport}'s) time that has passed since the last time it was shifted. This is followed by classifying (through its \texttt{Classifier}) the \texttt{FeatureInfluence} into a \texttt{Label} (or more specifically, one \texttt{Label} per active \texttt{Transform}), which is used by the \texttt{MemorySpace} to generate a list of \texttt{PeakEvent}s, which are inserted into the currently stored \texttt{Peaks} object in the \texttt{ActivityPattern}. The \texttt{Peaks} are stored as three sequences of \texttt{np.ndarray} of equal lengths, where a particular index in one of the arrays is associated with the same index in any of the other arrays, but the entries are not sorted in any way, and multiple indices corresponding to a single \texttt{CorpusEvent} is possible. The \texttt{Peaks} are stored by time, as most \texttt{ActivityPattern}s (e.g. the \texttt{ClassicActivityPattern}) shift peaks continuously in time, so the original association to a particular \texttt{CorpusEvent} is lost at this point, as the peak is stored by its time rather than by its index.

\subsubsection{Player.new\_event \& Player.step}
The final set of functions are \texttt{Player.new\_event} and \texttt{Player.step}, which both take the current state of the \texttt{Player} into account to select the next \texttt{CorpusEvent} that should be played. 

The \texttt{Player.new\_event} collects all of the \texttt{Peaks} (after shifting them based on the amount of time that has passed since the previous shift) from each \texttt{Atom} (or, again, more specifically from the \texttt{ActivityPattern} of each \texttt{Atom}), merges them through the \texttt{MergeAction.merge} function, scales them through all of its \texttt{ScaleAction}s, and finally selects from the \texttt{Peaks} which corresponding \texttt{CorpusEvent} to output through the \texttt{PeakSelector}. In case no peaks exist in the \texttt{Peaks} object, the \texttt{FallbackSelector} is used to select an appropriate \texttt{CorpusEvent} from the entire \texttt{Corpus} (typically the one following the previously output event, but a number of conditions exist here). 

Finally, once the \texttt{CorpusEvent} has been selected, the \texttt{Player.\_feedback} function will be called. This function will inform all of the \texttt{Player}'s subcomponents about which event was output so that they can update the state if necessary. This is also where all the \texttt{self\_influenced} \texttt{Atom}s are influenced.

The \texttt{Player.step} function is similar to the \texttt{Player.new\_event} function in terms of purpose, i.e. to play the next \texttt{CorpusEvent}, but will bypass everything related to \texttt{Peaks} and simply play the consecutive event in the \texttt{Corpus}. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% COMPILATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compilation}\label{ssec:2-compilation}

In order to facilitate the installation process for Max-oriented end users, the Python code is with each release "compiled" into a standalone application so that the user won't have to install Python to run Somax. This procedure is done through PyInstaller \cite{pyinstaller2023}, which packages the Somax code along with the Python interpreter and all necessary dependencies into a bundle. In other words, the code is not compiled, but rather packaged into a self-contained bundle.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Why PyInstaller?}\label{ssec:2-why-pyinstaller}
There are a number of libraries for packaging (or transpiling) Python code into standalone applications or libraries, for example Py2app, cx\_freeze, PyOxidizer and Nuitka, to name a few. The reason why we choose to use PyInstaller was simply because at the point in time when the Somax packaging procedure was conceived, PyInstaller was the only library that supported all of the following: (1) MacOS notarization (2) the Python multiprocessing library, (3) backwards compatibility with MacOS 10.13 High Sierra (which at this point was decided to be the oldest version Somax should support). 

It's however possible that this has changed over the past years, and that PyInstaller may no longer be the only viable nor the best option. The procedure outlined in this section is merely one way to package the Somax library into a standalone application that is known to work, but the reader is free to use any other procedure.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Procedure \& Requirements}\label{ssec:2-pyinstaller-procedure}

PyInstaller does not support cross-compilation, neither in terms of versions of MacOS nor Windows.\footnote{Note that only the procedure for building a MacOS .app bundle is outlined here. There's currently no official Windows release of Somax, but it is possible to run Somax on Windows with some caveats. See \url{https://github.com/DYCI2/Somax2/wiki/Somax2-on-Windows} for more information.} One of the curiosities of PyInstaller is that in terms of (major) MacOS versions, it's forward compatible but not backward compatible. It's therefore necessary to package the bundle on the oldest version that should be supported. In our case, this is currently MacOS High Sierra (10.13), but this should probably be revised in the future. The Somax bundle when packaged on High Sierra has proven to work on High Sierra (10.13), Mojave (10.14), Catalina (10.15), Big Sur (11), Monterey (12) and Ventura (13). 

High Sierra does however not support notarization, as this feature was added in Catalina, so the bundle needs to be notarized on a machine running MacOS Catalina or later (recommended Big Sur or later due to significantly easier to use \texttt{notarytool} that was added in Big Sur)

The same issues with backward compatibility applies to architectures: PyInstaller bundles created on \texttt{x86\_64} (Intel) will run on \texttt{arm64} (M1, M2, ...) processors, but not the other way around. 

In other words, the procedure for building can be summarized as follows: (1) package the bundle using PyInstaller on an Intel machine running MacOS High Sierra, (2) notarize the bundle on any machine (Intel or ARM) running Big Sur or later. The entire procedure for building is outlined in the \texttt{Makefile} in the root folder of the Somax2 repository, but will also be described below. Note that it's possible to to complete all of the steps on a single machine by running multiple versions of the OS in virtual environments (Parallels, VMware Fusion, VirtualBox, etc.).

\subsubsection{Bundle Requirements}
The following requirements are by no means exhaustive, but are known to work for bundling the package using PyInstaller on MacOS High Sierra (i.e. Step 1 below, all of the following steps can be done on any machine running MacOS Big Sur or later):

\begin{description}
	\item [Host Machine:] Intel x86-64
	\item [MacOS Version:] High Sierra 10.13.6
	\item [Python Version:] Python 3.9.5 (local \texttt{brew} installation, i.e. \texttt{brew install python@3.9})
	\item [PyInstaller Version:] PyInstaller 4.10
	\item [Dependencies:] See \texttt{Somax2/python/somax/requirements-pyinstaller.txt} (i.e. \texttt{pip3 install -r requirements-pyinstaller.txt})
\end{description}

\subsubsection{Step 1: PyInstaller Bundle}
The PyInstaller bundle is created by running \texttt{make pyinstaller} from the root folder on the High Sierra machine/VM. This requires the Ircam developer's certificate (\texttt{"Developer ID Application: INST RECHER COORD ACOUST MUSICALE"}) to be available on the machine.\footnote{The procedure of obtaining/using the Ircam developer's certificate will not be described here, but there are a number of internal Ircam documents describing this as well as the procedure for properly signing/notarizing an application, a \texttt{dmg} and/or a \texttt{pkg}.} 

\subsubsection{Step 1.1: Re-Signing the Bundle}
Due to an issue with the \texttt{sklearn} package (which is a dependency of \texttt{librosa}) on High Sierra, we will have to re-sign the bundle after building it. This is done by running \texttt{make codesignature} (on any version of MacOS / any architecture). If, in the future, the minimum MacOS version supported should change to Mojave or later, this step can be ignored.

\subsubsection{Step 2: Notarizing the Bundle}
On a machine running MacOS Big Sur or later (on any architecture), run \texttt{make notarize} to notarize the built application. For this step to work, you will need to register your app-specific password\footnote{For more info on generating an app-specific password, refer to the internal document "DÃ©veloppement Apple Ã  lâ€™Ircam".} under the profile name \texttt{repmus} (or adapt the \texttt{Makefile} to match your registered app-specific password) using \texttt{xcrun notarytool store-credentials}.

\subsubsection{Step 3: Creating the Max Package}
The final step in the procedure is to create the Max package, containing the signed and notarized bundle. Normally when we launch the server from Max (e.g. through the \texttt{Start Server} button of the \texttt{somax.server.app} or the \texttt{initialize} message to the \texttt{somax.server} from the GitHub repository, this will launch the \texttt{launch\_local} script in the \texttt{max/somax/misc} folder, which runs the \texttt{somax\_server.py} through the local Python installation. In the Max package, we want this to point to the packaged \texttt{somax\_server.app} instead. To do this, open the \texttt{somax.interpreter.maxpat} and change the \texttt{loadmess 0} into \texttt{loadmess 1}.

\begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.5\textwidth, keepaspectratio]{figures/somax_interpreter.png}
    \caption{\texttt{somax.interpreter.maxpat}}
    \label{fig:myFig}
\end{figure}

Once this is done, run \texttt{make max-package} to create the final dmg containing the Max package. This step currently requires the \texttt{create-dmg} formulae that can be installed through \texttt{brew}. It's however not mandatory to use this, it will simply resize the installed dmg to a good format and change the background image, and all of these steps could be done manually.

Also note that should any of the steps fail, there's are two commands to clean up: \texttt{make clean} and \texttt{make clean-all}. \texttt{make clean} will remove the \texttt{build} folder and other files related ot the building step, so if for example step 3 fails, running \texttt{make clean} will reset the build to the state it was in at end of the previous step (i.e. after step 2 has succeeded). Running \texttt{make clean-all} will in addition remove the \texttt{dist} folder, which contains the signed application, and will therefore reset the state so that the build procedure must be restarted from step 1.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{PyPI Package}\label{ssec:2-pypi-package}
The \texttt{Somax2/python/somax} folder is structured as a PyPI package, but recent versions of Somax have not been published to PyPI due to lack of interest in the Python code. Should this change in the future, it's possible to create new distributions through the normal procedure of PyPI packaging, e.g. (after incrementing version, etc.):
\begin{lstlisting}
python3 setup.py sdist bdist_wheel
twine check dist/*
twine upload dist/*
\end{lstlisting}



