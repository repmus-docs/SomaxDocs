\chapter{The Max Architecture}\label{sec:3-max-architecture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OVERVIEW
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}\label{ssec:3-overview}
The Somax Max package is responsible for two things: It serves as the front-end/API for the end user and it's responsible for handling every aspect of real-time signal processing. Everything else is handled by the Python code base. 

At the core of the Max package are the \texttt{somax.server} and \texttt{somax.player} objects, both which are essentially wrappers around one pair of \texttt{udpsend}-\texttt{updreceive} each, through which they manage all communication with their corresponding \texttt{SomaxServer} and \texttt{OscAgent} Python objects respectively. These two objects have been designed with a single goal in mind: to behave as if they were native Max objects.

One explicit requirement for the entire project has been that as much of the code as possible should be written only in Python and Max. Since Somax is a research project, it was considered likely that future members and developers on the team mainly would have experience with Python and Max, and that it for this reason could  be difficult to maintain the code in the future if a significant portion of it was written in C/C++.

For this reason, the entire Max part of the Somax code base has been written as abstractions rather than externals. While this does increase the transparency for Max developers, it comes with a number of downsides that all make the above mentioned goal more difficult, that will be discussed thoroughly in this chapter. 

This chapter assumes that the reader has good knowledge of Max and will not explain basic aspects of Max that it frequently relies on (e.g. \texttt{pattr}, \texttt{bpatchers}, the distinction between \texttt{patchers} and \texttt{abstractions}, the Max threading model, etc.), but rather focus on the code base itself in order to give an overview

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The Max Package's Structure}\label{ssec:3-structure}
The Somax package consists of more than 50 abstractions, but most of them are used internally in a few core object, rather than being relevant for the end user. In this chapter, we will only focus on these core objects, as most of the abstractions can easily be understood from their corresponding contexts.

\noindent The base objects of the package are: 

\begin{description}
	\item[\texttt{somax.server}] which handles the communication with the Python server
	\item[\texttt{somax.player}] which handles the communication with a particular \texttt{OscAgent} on the server
	\item[\texttt{somax.audiocorpusbuilder}] which is the front-end to the \texttt{CorpusBuilder} when used to create a \texttt{Corpus} from an audio file
	\item[\texttt{somax.midicorpusbuilder}] which is the front-end to the \texttt{CorpusBuilder} when used to create a \texttt{Corpus} from a MIDI file
	\item[\texttt{somax.audioinfluencer}] which is used to analyze a real-time signal in the same manner as the \texttt{Corpus} is analyzed when built, segmenting the signal into discrete, symbolic data that are used to influence the \texttt{Player}
	\item[\texttt{somax.midiinfluencer}] same as above but for real-time MIDI streams
	\item[\texttt{somax.audiorenderer}] which converts the symbolic messages received from the \texttt{OscAgent} into real-time audio data when using an audio \texttt{Corpus}
	\item[\texttt{somax.midirenderer}] same as above for a for an \texttt{OscAgent} with a MIDI \texttt{Corpus}.
\end{description}

\noindent These objects are intended for any user who wishes to use any part of the Somax library in a modular manner. Two further variations exist for a number of those objects. \texttt{somax.<object>.ui} and \texttt{somax.<object>.app}. The former is for each object just a condensed UI suitable for using in a bpatcher, but in terms of messages and functionality identical to the core objects. The latter set of objects are application-style bpatcher objects designed for users with little or no experience in Max, where all of the functionality, including input and output, is encapsulated, with little room for the user to customize the design/behaviour of the object. The \texttt{.ui} objects that exist are \texttt{somax.player.ui}, \texttt{somax.audioinfluencer.ui} and \texttt{somax.midiinfluencer.ui}. The \texttt{.app} objects that exist are \texttt{somax.player.app}, \texttt{somax.server.app}, \texttt{somax.audioinfluencer.app} and \texttt{somax.midiinfluencer.app}. The latter set of objects will be further described in section \ref{ssec:3-app-objects}, while all other sections mainly will focus on the base objects (i.e. the objects with neither an \texttt{.ui} nor \texttt{.app} extension).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Design Guidelines}\label{ssec:3-design-guidelines}
To achieve the goal mentioned above, i.e. that all base objects should behave as if they were native Max objects, or more specifically as if they were well-designed, compiled externals, the following set of guidelines were developed:

\subsubsection{Clear Separation Between Attributes and Messages}
An attribute of an object is a setting or property that tells the object how to do its job. While this is a fundamental principle of modern Max objects, it's quite difficult to achieve for objects whose state actually is stored on a remote server, that may or may not have been started when the object is created. This will be discussed in section \ref{ssec:3-osc-issues}.

In addition, passing attributes to abstractions comes with a number of issues in Max, which will be discussed in section \ref{ssec:3-abstractions}

\subsubsection{Errors Should Be Explicit}
Passing incorrect messages, values of the wrong type or attributes that don't exist to an object should always produce an explicit error (typically printed to the Max console), and if the message is an important part of a control flow that the user may rely on, the object should output a message or error code to indicating the error, so that the user can react accordingly. For example, if the \texttt{somax.audiocorpusbuilder} fails to build a corpus, a message indicating what went wrong will be printed in the Max console as well as the error code being output on the first outlet of the \texttt{somax.audiocorpusbuilder}, so that the user is able to react programmatically when this happens.


\subsubsection{All Attributes Should Be Exposed to Pattr}
Any attribute that the user may want to control should be exposed to the Max \texttt{pattr} system in order to allow the user to store, load and interpolate between states and configurations of the different objects.

\subsubsection{Avoid Global State}
The usage of global state (such as global \texttt{value}, \texttt{send} and \texttt{receive}, \texttt{dict} and \texttt{coll}, etc.) should be avoided at all costs and only used when absolutely necessary. By global, we mean state that is shared outside of a given abstraction, i.e. any send/receive/dict/etc. without \texttt{\#0} in its name. The reason for this is simple: global state makes the code so much more difficult to read. 

With that said, there are still a number of cases where global state is necessary in the Somax library. These will be discussed in section \ref{ssec:3-global-state}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{OSC Communication Issues}\label{ssec:3-osc-issues}
All of the communication between Max and Python is handled through (UDP-based) OSC. There are several benefits of choosing UDP-based OSC, it's efficient for real-time messaging and it's compatible with a number of different environments (most programming languages and music-oriented coding environments have actively maintained OSC modules). But most of its downsides are highly problematic for our use case: the fact that we cannot be sure whether the message was received, that there's no synchronous sending in Max, that messages may get silently dropped if the socket is full, and finally that we cannot send objects larger than a couple of kilobytes (size varies slightly between implementations).

Most of these issues are however only problematic in the initialization step, when establishing a connection between Max and Python, creating the remote representations of the \texttt{somax.player} and loading a corpus. For runtime messages, if a message should be dropped, this would in the absolute worst case result in a second or two of silence (which likely would sound like a musical pause), but in most cases, it wouldn't have any real consequences at all. For the initialization, however, there are a number of things that could go wrong. For example, if a user sends a message from Max to a remote \texttt{Player} (for example setting a certain parameter) while the remote \texttt{Player} still is in the middle of initializing and has yet to establish the UDP connection, the message sent by the user will be dropped and there's no way for the user to know that this has happened. This means that the UI in Max will indicate one value but the actual value used by the remote \texttt{Player} is another. 

Now, one could claim that it's perfectly legitimate to assume that the user would understand that it's not possible to set parameters until the initialization of the remote \texttt{Player} is complete, and while this is true to some extent, it would make the objects cumbersome to use in Max, as it wouldn't be possible to rely on normal initialization / control flow mechanics in Max such as attributes, loadbangs or pattr, and the it would be important to manually keep track of the order that the messages are sent in, thus departing far from the standards of Max programming.

With this in mind, the objects that rely on communication with the remote Python server (i.e. the \texttt{somax.server} and \texttt{somax.player} objects in Max) have been designed to store its internal state inside the object as well as on the remote. This means that if the remote crashes, is restarted, or if parameters are set before the remote has been started, it's possible to just update the remote by sending the state as it has been stored in Max. This means that the objects can be used in a normal manner, where we can set any attribute at initialization independently of whether the remote is running, and then just output it after the initialization procedure has been completed. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Abstraction Issues}\label{ssec:3-abstractions}

The second main issue of the Somax library is related to the requirement of writing the Max code as abstractions rather than externals. While this comes with a number of benefits, mainly in terms of transparency for the user, the major problem with abstractions in Max is that they behave differently than externals on initialization. Consider the example in figure \ref{fig:3-abstractions-externals}. Assuming that the \texttt{myabstraction} object is an abstraction (which relies on \texttt{patcherargs} to pass attributes) and the \texttt{myexternal} is an external (where the attribute is a member variable), the value of the attribute \texttt{somevalue} will be different in these two objects. In the external object, \texttt{somevalue} will be set to 1 when the object is initialized, then immediately changed to 2 by the \texttt{loadbang}, as we expect. In the abstraction, the object will be initialized without a given value for \texttt{somevalue}, then the \texttt{loadbang} will set it to 2, followed by the deferlow'ed \texttt{patcherargs} setting it to 1. So in the object on the left, the value for \texttt{somevalue} will be 1 but in the object on the right, the value will be 2.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.7\textwidth, keepaspectratio]{figures/abstractions-externals.png}
    \caption{The abstraction inconsistency}
    \label{fig:3-abstractions-externals}
\end{figure}

\noindent Now, one could claim that this is a rather marginal case that won't be of huge importance, as you wouldn't set the attribute to one value and then immediately change it afterwards regardless. This is true for top-level objects, but becomes problematic for any nested abstraction. Consider the case in figure \ref{fig:3-nested-abstractions}. Here, \texttt{myplayer.app} is an abstraction that contains \texttt{myplayer} (among many other objects, omitted for space), where we want the default value for the attribute \texttt{mode}, when used in this particular abstraction, to be \texttt{continuous}, but the user may want to change this value immediately as part of their own configuration. If \texttt{myplayer} was an external, this would work as intended, but since \texttt{myplayer} is an external, the \texttt{patcherargs} will overwrite the user settings as sent by the \texttt{loadbang}.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.6\textwidth, keepaspectratio]{figures/nested-abstractions.png}
    \caption{Nested abstractions}
    \label{fig:3-nested-abstractions}
\end{figure}

\noindent Unfortunately, there are a number of issues related to nested abstractions, such as the difficulty to pass any number of attributes from one abstraction to another (requires nested \texttt{patcherargs} where we cannot ensure the order), the difficulty to set default arguments (passing arguments from one abstraction to another with the \texttt{\#1}-syntax will be replaced with \texttt{0} if the user doesn't provide any argument to the outer abstraction). Yet another issue is the fact that there's no way to fail initialization of the abstraction (as in figure \ref{fig:3-failed-init}) if invalid arguments are passed to the abstraction. This can be very problematic if the abstraction is manipulating some global state or performing I/O-operations. A concrete example in the Somax library would be if \texttt{somax.player} is initialized with invalid OSC ports, which unless properly handled would create the \texttt{OscAgent} on the server but then be unable to communicate with it (including deleting it). Or even worse, if its initialized with an OSC port used by another \texttt{somax.player}, which would create all sorts of issues between the two players.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.25\textwidth, keepaspectratio]{figures/failed-external.png}
    \caption{An external that failed initialization since the arguments were invalid}
    \label{fig:3-failed-init}
\end{figure}

\noindent The workaround for most of these problems lies in the \texttt{somax.await\_patcherargs} abstraction. This object is modelled on the \texttt{bach.args} object from the Bach library \cite{agostini2012bach} and will store any messages sent to the abstraction and not output them until the \texttt{patcherargs} initialization is done, hence ensuring correct initialization order. Unlike the \texttt{bach.args} object, this object will also allow explicit initialization failures if the object is initialized with invalid arguments. In this case, the \texttt{somax.await\_patcherargs} will continue to block any input to ensure that no I/O-operations or global state changes are done while the object is invalid. If the issues causing the initialization to fail are resolved, it's possible to reinitialize the object with the \texttt{reload} command.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Global State}\label{ssec:3-global-state}
While one of the main guidelines presented in section \ref{ssec:3-design-guidelines} was that global state should be avoided as much as possible, some interaction between certain objects is necessary. This could've be solved by directly connecting the objects to each other (which, in fact, was the case in early versions of Somax 2), but from a user perspective, this would've been inconvenient and difficult to understand, as it is related to internal implementation details that the user shouldn't have to be aware of. Global state is therefore used in the following cases:

\subsubsection{Initialization of server and players}
The \texttt{somax.server} and \texttt{somax.player} (or more specifically the \texttt{somax.unique\_number} abstraction inside the \texttt{somax.player.core} object) objects store their corresponding OSC ports in the global \texttt{somax.recvports}. This allows us to automatically assign OSC ports when new \texttt{somax.player}s are created, as well as ensure that if an object is created with manual ports that are already used elsewhere, the initialization will fail. Ports are removed from the dictionary when the \texttt{somax.player} or \texttt{somax.server} are deallocated.

The \texttt{somax.player} also stores its name in the \texttt{somax.players} dict (through the \texttt{somax.uniuqname} object)  to ensure that two players with the same name cannot be created on the server.

Finally, the \texttt{somax.server} stores an internal counter of the number of \texttt{somax.server} objects that currently exists in Max, to avoid duplicate servers. This is stored in the \texttt{somax.num\_servers} \texttt{value} object.

\subsubsection{Communication between server and player}
Nearly all communication between the remote \texttt{SomaxServer} and \texttt{OscAgent} (which correspond to the \texttt{somax.server} and \texttt{somax.player} objects in Max) is handled directly on the Python side, but there are a couple of cases where communication directly between the \texttt{somax.server} and \texttt{somax.player} local objects is necessary. These are:
\begin{itemize}
	\item When the remote \texttt{OscAgent} is created. This message is sent from the \texttt{somax.player} to the \texttt{somax.server}, which sends the message to the \texttt{SomaxServer} to create the \texttt{OscAgent}. 
	\item When the \texttt{somax.server} crashes or is terminated in a manner that doesn't allow the remote \texttt{OscAgent} to inform its local \texttt{somax.player} to stop playing.
	\item When the \texttt{somax.server}'s transport is started or stopped.
\end{itemize}

\noindent These messages are handled with global \texttt{send}-\texttt{receive} pairs on the addresses \texttt{somax.from\_server} for messages from \texttt{somax.server} to \texttt{somax.player}) and \texttt{somax.to\_server} for messages from \texttt{somax.player} to \texttt{somax.server}.


\subsubsection{Communication between server and corpus builder}

The \texttt{somax.midicorpusbuilder} and \texttt{somax.audiocorpusbuilder} objects do not have their own pairs of \texttt{udpsend} and \texttt{udpreceive}, but communicates through the \texttt{somax.server}. Messages from either of the local corpus builders and their remote counterparts are therefore sent through the \texttt{somax.server}, and uses the same send/receive addresses as in the above paragraph (\texttt{somax.from\_server} and \texttt{somax.to\_server}).


\subsubsection{Corpus path}
The \texttt{corpuspath} is the folder to which all corpus builders will export their corpora when built, as well as the folder where all \texttt{somax.player}s by default will search for corpora and associated audio files. The corpus path is fully managed by the \texttt{somax.corpuspath} abstraction, which internally uses the \texttt{value} object with name \texttt{somax.corpuspath} to store the corpus path, as well as \texttt{send}-\texttt{receive} address \texttt{somax.corpuspath\_update}, which triggers an update in all \texttt{somax.corpuspath} objects when the path is updated in one of them.


\subsubsection{Communication between .app objects}
Since some of the explicit requirements for the \texttt{somax.<object>.app} objects (described in section \ref{ssec:3-app-objects}) are that they should be self contained, support fully dynamic routing of influences between objects and be duplicatable without having to leave presentation mode (i.e. without having to add or remove any patch cords), global sends and receives is a must here. 

Influence messages between .app objects are are sent through the \texttt{somax.source} object (contained in any \texttt{.app} object that has an influencer) using an address specific for that particular source with the format \texttt{source.<name>} (where \texttt{<name>} is the name of the object, e.g. \texttt{Player2} or \texttt{AudioInfluencer}). These names are also stored in the dictionary \texttt{somax.sources}.

Finally, the \texttt{somax.routing} send/receive-address is used whenever a source is added or removed to update any related UI object, for example to remove the source from all associated \texttt{umenu}s if the source is deleted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SERVER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Server Object}\label{ssec:3-server}

The \texttt{somax.server} object manages all communication with the \texttt{SomaxServer} class in Python, and is responsible for launching the Python application/script as well as managing its lifetime. From a development point of view, the \texttt{somax.server} object has five different phases: (1) object initialization, (2) remote initialization, (3) runtime, (4) remote termination, (5) object deletion. Note that this is different from what the status outlet (second outlet of the \texttt{somax.server} object) shows: this outlet shows the different states as a result from the different phases. Figure \ref{fig:3-server-states} illustrates the relation between the phases and the states of the object. The state is continuously polled by the \texttt{somax.serverstatus} abstraction, which continuously sends requests over OSC to check whether the remote server is responding and update its status.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.6\textwidth, keepaspectratio]{figures/server_state.png}
    \caption{State transition diagram for the \texttt{somax.server} object. The rounded rectangular objects represent the states as shown on the second outlet of the object and arrows indicate name of messages sent to the \texttt{somax.server} object (parenthesized text represent cases, not messages). Note that the diamond blocks do not necessarily represent conditions (for example the "remote termination" phase cannot meaningfully fail) they are only used to illustrate the different phases/transitions described in this text.} 
    \label{fig:3-server-states}
\end{figure}

%%%

\subsubsection{Object Initialization}
When the \texttt{somax.server} object is created, the strategy described in section \ref{ssec:3-abstractions} is used to handle \texttt{patcherargs} accordingly. There are three possible outcomes here:
\begin{itemize}
	\item The initialization fails because invalid arguments are provided (for example a port that is already in use\footnote{Note that while it's possible to initialize the server with custom ports and/or ip, it will not be possible to launch the server through the user interface in this case. To do this, the server must be manually launched from a terminal.}). The state will be \texttt{invalid} and the object will ignore all messages.
	\item The initialization fails because another \texttt{somax.server} already exists. The state will be \texttt{duplicate} and the object will ignore all messages except the \texttt{reload} message.
	\item The initialization succeeds. The state will be \texttt{offline} and accept any messages.
\end{itemize}

\noindent The reason why it's important for this step to be able to fail is because \texttt{somax.player} sends their \texttt{create\_agent} messages to the \texttt{somax.to\_server} address. If we have two initialized \texttt{somax.server} objects, this means that we will receive it twice and therefore create two duplicate remote agents, causing all sorts of issues. The same issue applies to all messages in general: even if we send a message directly on the inlet of one of two duplicate \texttt{somax.server} objects, we will only send a single message through the \texttt{udpsend}, but any response from the remote server will be received on both of the \texttt{udpreceive}, and hence risk causing a number of issues. The duplication status is handled through the internal \texttt{somax.num\_servers} \texttt{value} object mentioned in section \ref{ssec:3-global-state}, which is incremented when the object is created, independently of whether initialization succeeded or not. The ports used by the object are also stored in the \texttt{somax.recvports} dictionary.

Sending \texttt{reload} to a \texttt{somax.server} object will trigger the procedure described under "Object Deletion" immediately followed by the "Object Initialization"

All \texttt{loadbang}/\texttt{loadmess} messages are handled when the object is created (technically before the \texttt{patcherargs}, but this will only set the default values for a number of parameters and settings, it will not trigger any output, and the order that the \texttt{loadbang}s are executed in is (and should always be) irrelevant.

%%%

\subsubsection{Remote Initialization}
When the \texttt{initialize} message is sent to the \texttt{somax.server} (internally or externally – the \texttt{autoinitialize} attribute will trigger the \texttt{initialize} message internally once object initialization is complete), the remote server script/application will be launched through the \texttt{somax.interpreter}, specifically by using the \texttt{;max launchbrowser} command, which opens the provided file in the default application. Once the server has been properly launched, the \texttt{SomaxServer} will immediately send the message \texttt{initialized} over OSC, which will be output on the first outlet of the \texttt{somax.server} object, as well as send its currently stored value for all relevant attributes (currently only \texttt{tempo} and \texttt{active}).

%%%

\subsubsection{Runtime}
The runtime phase, from when the connection between the local \texttt{somax.server} and the remote \texttt{SomaxServer} has been established (represented by the states \texttt{playersmissing}, \texttt{ready} and \texttt{running}) is where the user likely spends 99\% of the time, but is from a development point of view the phase that requires the least amount of work. During this phase, any message sent to the \texttt{somax.server} object will simply be sent directly to the server (but stateful messages, such as \texttt{tempo} and \texttt{active} will also stored locally, in case the server is restarted).

During this phase, the \texttt{somax.serverstatus} will continuously poll the remote server, by sending a list of the names of all the local \texttt{somax.player} objects that exist in Max. The remote server will respond with two values, one boolean indicating whether all of these objects also exist on the remote (if not, the status will be \texttt{playersmissing}) and whether the server's transport is active (status: \texttt{running} or not (status: \texttt{ready}). Typically, the remote server should always be able to respond to these requests within a second, as all of its heavy operations are computed in separate threads, but in some cases (for example when running "Test Segmentation" from the \texttt{somax.audiocorpusbuilder}), the server will change its status to \texttt{working}, indicating that it didn't receive any response. If the server doesn't receive any response for 25 seconds, the \texttt{somax.serverstatus} will assume that the server has crashed and change the status to \texttt{terminated} (not represented in figure \ref{fig:3-server-states}).

%%%

\subsubsection{Remote Termination}
When an explicit \texttt{terminate} message is sent by the user, the remote server will be shut down and trigger the \texttt{terminated} message before closing. It will before shutting down delete all of its remote \texttt{OscAgent}s and thereby trigger \texttt{terminated} messages to all corresponding \texttt{somax.player}s. The \texttt{somax.serverstatus} will receive the \texttt{terminated} message and change its state to \texttt{terminated}. Note that this state is internally identical to \texttt{offline}.


%%%

\subsubsection{Object Deletion}
When the \texttt{somax.server} object deleted, the \texttt{freebang} is triggered, which decrements the \texttt{somax.num\_servers} \texttt{value} is decremented and its ports are deallocated from the  \texttt{somax.recvports} dictionary. If the \texttt{autoterminate} attribute is enabled (which is the default case), the remote server will also be shut down as if \texttt{terminate} was explicitly called\footnote{Note that this is not represented in figure \ref{fig:3-server-states}, but the object can obviously be deleted from any of the states above, so a direct transition from any state to the deletion phase is possible and non-problematic)}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PLAYER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Player Object}\label{ssec:3-player}

The \texttt{somax.player} corresponds to a single \texttt{OscAgent} instance on the remote. Since this object corresponds to a remote object, it will have the same five phases as the \texttt{somax.server} (object initialization, remote initialization, runtime, remote termination and object deletion), but only the first two are complicated in terms of implementations. From a user point of view, we're only concerned with one thing: is the object initialized on the remote server or not. This is why the status outlet (second outlet) of the \texttt{somax.player} is much more simple than that of the \texttt{somax.server}.

The \texttt{somax.player} is divided into two abstractions, the \texttt{somax.player} and the \texttt{somax.player.core}. The \texttt{somax.player.core} corresponds to a generic class that is mandatory for any player, while the \texttt{somax.player} object is the implementation of a specific player consisting of four \texttt{Atom}s, a specific set of \texttt{ScaleAction}s and loads of exposed parameters. It would however be possible to use the \texttt{somax.player.core} to implement a different configuration of a player, for example an OMax-like player with only a single, self-influenced \texttt{Atom}, or a highly complex player with 8 different layers corresponding to different musical dimensions. In terms of roles, the \texttt{somax.player.core} is responsible for the initialization and termination of the remote \texttt{Player} instance (the former is managed through local sends/receives to the \texttt{somax.server}) as well as OSC-communication with the remote \texttt{OscAgent} once it has been created, while the \texttt{somax.player} is responsible for the initialization of the \texttt{Player}s subcomponents (\texttt{Atom}, \texttt{ScaleAction}, \texttt{PeakSelector}, etc.) as well as storing and managing the state of all of the remote parameters.

%%%

\subsubsection{Object Initialization}
When a \texttt{somax.player} is created, there are two main steps: initialization of the \texttt{somax.player.core} and initialization of the \texttt{somax.player}. The initialization of the \texttt{somax.player.core} is similar to the procedure described for the \texttt{somax.server}. The object takes four arguments: the name of the player, OSC send port, OSC receive port and ip address of the remote player. 

If no arguments are provided, it will automatically be assigned a unique name (using \texttt{\#0}-syntax) and the first two available ports that aren't in use by any other Somax object (through the \texttt{somax.recvports} dictionary). In this case, initialization of the \texttt{somax.player.core} cannot fail. If the user provides a name manually, this name will be changed to \texttt{<name>\_\#0} if another \texttt{somax.player} with the same name already exists. If the user provides manual ports and those ports are already in use by another \texttt{somax.player} or \texttt{somax.server}, the object initialization will fail (through \texttt{somax.await\_patcherargs}, as explained in section \ref{ssec:3-abstractions}). If the initialization succeeds, the name and ports will be stored in their corresponding so that no other player may use them while the object exists.

The \texttt{somax.player} is responsible for all remote parameters, which are handled as attributes in Max. When created, all attributes are set to their default values through a \texttt{loadbang}/\texttt{loadmess}, but does not trigger any output\footnote{Note that all parameters are accessible through \texttt{pattr}, so while the message \texttt{set \$1} typically doesn't trigger any output from the object itself, the internal \texttt{pattr} will still be updated, and this triggers output on the third outlet through the \texttt{pattstorage} object}. After that, the \texttt{patcherargs} is used to parse any attributes provided by the user. Note that initialization of the \texttt{somax.player} cannot fail, only its contained \texttt{somax.player.core} may fail.

%%%

\subsubsection{Remote Initialization}
When the \texttt{initialize} message is sent to the \texttt{somax.player} (internally or externally – the \texttt{autoinitialize} attribute will trigger the \texttt{initialize} message internally once object initialization is complete), the remote initialization will begin. This process is a bit more complicated than the \texttt{somax.server}'s initialization, as the remote \texttt{Player} contains a number of subcomponents (\texttt{Atom}s, \texttt{ScaleAction}s, etc.), which in turn have a number of parameters, and we can obviously not set the value of a particular component's parameters before the component has been created. The remote initialization procedure is as follows:

\begin{itemize}
\item[(i)] the \texttt{somax.player.core} will send the \texttt{create\_agent} message to any existing \texttt{somax.server} through the \texttt{somax.to\_server} address, which will send it to the remote server over OSC (this step will obviously fail if no \texttt{somax.server} exists or if the remote \texttt{SomaxServer} isn't initialized), creating and starting the \texttt{OscAgent}, which sends the message \texttt{initialized} over OSC immediately after it has been started. This message is received by the \texttt{somax.player.core} but consumed by the \texttt{somax.player} (in other words, it will not be output through the outlet of the \texttt{somax.player}) to trigger (iii)

\item[(ii)] When the \texttt{somax.player} receives the \texttt{initialized} message, it will send OSC messages to the remote \texttt{OscAgent} to instantiate all of its \texttt{Atom}s. For each \texttt{Atom} created, the remote will respond with a list of the names of all created \texttt{Atom}s. When this list has the length of four (i.e. when the last of the four \texttt{Atom}s used in the default configuration is instantiated) it will trigger step (iii)

\item[(iii)] Once all \texttt{Atom}s are instantiated, the \texttt{somax.player} will send the values of all of its stored parameters to the remote \texttt{OscAgent} in no specific order. If two parameters depend on each other, the order of initialization is handled locally in the \texttt{somax.player} (which is the case for some experimental parameters, for example taboo, where parameter \texttt{tabooenable} also triggers output of \texttt{tabooduration}). Once all parameter messages have been sent, the \texttt{somax.player} will output the \texttt{initialized} message and finally load any corpus, if the user has provided one before instantiation.
\end{itemize}

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.99\textwidth, keepaspectratio]{figures/player_initialization.png}
    \caption{The initialization code in \texttt{somax.player}}
    \label{fig:3-player-initialization}
\end{figure}

\noindent Note that the goal of this instantiation procedure is to achieve what was described in section \ref{ssec:3-osc-issues}. That is, to allow the user to set the parameters through normal means (attributes, loadbangs, etc.) at any time, without having to wait for the server/player to be online before doing this. It will ensure that the state is preserved if the player is terminated and reinitialized. In effect, we're allowing the user to build their own UI around the \texttt{somax.player} object, where the user always can be sure that the state of their UI will, as long as its value has been sent to the \texttt{somax.player}, always be the actual value of the parameter on the remote.

%%%

\subsubsection{Runtime}
Similarly to section \ref{ssec:3-server}, the runtime phase, which starts when the remote \texttt{OscAgent} is fully initialized (when the \texttt{somax.player} outputs the \texttt{initialized} message) is the most important phase for the user, but simple in terms of the \texttt{somax.player} object implementation. During this phase, the \texttt{somax.player}'s main role is to convert incoming Max messages (i.e. converting flat case messages into OSC function calls on the form \texttt{<func\_name> <param1>= <value1> <param2>= <value2> ...} into corresponding Python messages. 

There's a separation between \texttt{messages} on one hand and \texttt{attributes} on the other (which are clearly separated in the maxhelp of the \texttt{somax.player}). Messages are converted to the appropriate Python syntax and sent directly to the server without storing them. Attributes, on the other hand, generally revolve around some stateful object in Max (\texttt{toggle}, \texttt{number}, \texttt{value}, \texttt{slider}, etc.) and are typically set through the \texttt{pattrhub} object, which also triggers output from the targeted object and therefore updates the remote as well. There are also a couple of macro parameters (\texttt{mode}, \texttt{weights}, \texttt{transpositions}, etc.). These typically bypass pattr in order to accept and/or output messages with a better format. For example, the \texttt{matrixctrl} controlling transpositions will in Max output a 36-element list of \texttt{<row> <col> <value> <row> <col> <value>}, which is unnecessarily difficult to understand and use for a one-row fixed size \texttt{matrixctrl}, and is therefore converted into a 12-element indexmap before being output.

%%%

\subsubsection{Remote Termination \& Object Deletion}

For the \texttt{somax.player}, both of these are trivial. When the remote is terminated (through an explicit \texttt{terminate} message sent by the user through the \texttt{freebang} when the object is deleted), the \texttt{somax.player.core} will simply send the \texttt{terminate} message to the remote \texttt{OscAgent}, which terminates it and deletes it from the \texttt{SomaxServer}. When the object is deleted, the \texttt{somax.player.core} will deallocate its name and ports from their corresponding dictionaries (through the \texttt{somax.uniquename} and \texttt{somax.uniquenumber} abstractions in which they are stored).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PERIPHERALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Peripherals}\label{ssec:3-peripherals}
In the whole Somax architecture, 99\% of the development work revolves around the \texttt{somax.player} and \texttt{somax.server} objects and their associated Python code. Those objects are also the most difficult to get a good overview of, as it's not possible to understand exactly what's going on by reading the Python and Max code separately. It's also difficult to step through the code with a debugger, as there's no joint debugger for both Max and Python (it's obviously possible to step through individual function calls to Python, but that won't help with the overview. It's exactly for this reason that this document is written – to provide the developer with the overview that otherwise is difficult to achieve.

Apart from the \texttt{somax.server} and \texttt{somax.player} object, there are however six more base objects of the Somax Max library (\texttt{somax.audioinfluencer}, \texttt{somax.midiinfluencer}, \texttt{somax.audiorenderer}, \texttt{somax.midirenderer}, \texttt{somax.audiocorpusbuilder} and \\ \texttt{somax.midicorpusbuilder}, a number of UI-based utility objects (e.g. \texttt{somax.pan2}, \texttt{somax.midioutput}, \texttt{somax.audioinput}, etc.), a number of compact UI-based  versions of the base objects (\texttt{somax.<object>.ui}), application-style ready-to use objects for users with little or no experience with Max programming (\texttt{somax.<object>.app})  as well as over 50 "package-private" abstractions, i.e. abstractions that are reused in several places in the Somax package but typically not relevant to the end user. 

These objects are however typically small and self-contained in a more traditional sense, closely following the Max standard for abstractions, where all inputs and output are well-documented with no side effects or complex dependencies. An experienced Max developer shouldn't have to spend more than a minute or two to grasp the overview of any base, ui or app object apart from the \texttt{somax.server} or \texttt{somax.player}. Still, in the following sections, a couple of notes will be given on each of these objects for completeness.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Influencers}\label{ssec:3-influencers}
The \texttt{somax.audioinfluencer} and \texttt{somax.midiinfluencer} objects are responsible for segmenting and analyzing real-time audio / MIDI streams into discrete influences for the \texttt{Player.influence} function described in section \ref{ssec:2-player-functions}. This analysis procedure is more or less identical to the procedure for segmenting and analyzing the corpus (see section \ref{ssec:2-corpus}), but with fewer classifiers (only onset, pitch and chroma) and slightly different analysis algorithms (\texttt{bonk} for onset, \texttt{OMax.Yin+} for pitch and \texttt{ircamdescriptor~} for chroma in the audio case, and identical procedures as in the \texttt{CorpusBuilder} for MIDI). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Renderers}\label{ssec:3-renderers}
The \texttt{somax.audiorenderer} and \texttt{somax.midirenderer} converts the \texttt{RenderingMessage}s that the \texttt{OscAgent} sends each time it plays a new slice into real-time audio / MIDi streams to output. 

The MIDI renderer's implementation doesn't need any explanation, it's basically just a pass-through with some convenience functions to handle flushing in the case where the server crashes (or other cases of incorrect termination of a \texttt{somax.player}). 

The audio renderer utilizes $N$ parallel \texttt{groove$\sim$} (through \texttt{mc.groove$\sim$}) objects rendering the same \texttt{buffer$\sim$}, in which the audio file corresponding to the corpus is loaded, with crossfades between them occurring each time an \texttt{audio event} message is received. The \texttt{somax.audiorenderer} will ignore the end time of the event and continue playing the buffer linearly until it receives a new \texttt{audio event} message or an \texttt{audio audio\_off}, in which case it will stop playing. If the \texttt{AudioStateHandler} (see section \ref{ssec:2-scheduling-handler}) determines that an event is a direct continuation of the previous event, it will rather output a \texttt{audio continuation} message, in which case no crossfade is necessary and the renderer will simply continue playing the buffer linearly. It will however use the time stretch information even for \texttt{audio continuation} events, in case the user has changed the tempo since the last event was received.

This implementation is by no means perfect, all parallel $N$ \texttt{groove$\sim$} objects are playing all the time (even when they are muted) with possibly different time stretch and pitch shift factors, resulting in a high computational cost, which unfortunately is necessary since it typically takes 1-10 ms for a \texttt{groove$\sim$} to start playing once stopped. Also, if $N$ or more events are received within the threshold of the \texttt{release} parameter (default value: 150 ms), this is at risk of causing clipping issues in the audio. A typical renderer for granular or concatenative synthesis (e.g. \texttt{mubu.concat$\sim$}) would solve this issue, but currently there are no such renderers supporting per-grain time stretch / pitch shift. So unless an external is developed for this particular purpose, or \texttt{mubu.concat$\sim$} adds support for this, the current rendering strategy is likely the best one available.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Corpus Builders}\label{ssec:3-corpusbuilders}
The \texttt{somax.audiocorpusbuilder} and \texttt{somax.midicorpusbuilder} are UI objects designed for building the corpus through the \texttt{somax.server}. They are essentially abstractions with a single purpose: to format and send the \texttt{build\_corpus} command to the \texttt{SomaxServer}. The corpus builders do not have their own OSC addresses, communication is done internally through the \texttt{somax.to\_server} (on which it sends the \texttt{build\_corpus} command from the \texttt{somax.server}) and \texttt{somax.from\_server} (on which it receives status updates while building as well as the path to the built corpus when complete). 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{UI \& App Objects}\label{ssec:3-app-objects}
As mentioned in section \ref{ssec:3-structure}, there are two additional variations on each of the base objects: \texttt{somax.<object>.ui} and \texttt{somax.<object>.app}. The \texttt{.ui} objects are just convenient wrappers around the base objects that can be used as bpatchers with a condensed UI.

The \texttt{.app} objects encapsulate these \texttt{somax.<object>.ui} objects along with abstractions for audio / MIDI input and/or output when relevant (e.g. the \texttt{somax.audioinfluencer.app} has both an audio input abstraction, a \texttt{somax.audioinfluencer.app} and an audio output and an audio output abstraction). The \texttt{.app} objects also manage wireless routing of influences from influencers and any \texttt{somax.player.app} (which has influencers) to any other \texttt{somax.player.app} through the \texttt{somax.player.routing} abstraction. Internally, this is handled through the \texttt{source.<name>} addresses described in section \ref{ssec:3-global-state}.

