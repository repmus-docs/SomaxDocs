\chapter{Generate}\label{sec:3-generate}
 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.99\textwidth]{figures/3-somax-generate.png}
    \caption{The main steps in generating output from a continuous trigger stream.}
    \label{fig:3-somax-generate}
\end{figure}

So far, both section \ref{sec:3-corpus} and \ref{sec:3-influence} have described a number of procedures for updating the internal state of the system without generating any output. This section will describe the steps taken to generate output from a continuous trigger stream $\mathcal Y$ of (an often undefined) length $W$ based on the state set by recent influences, for which the procedure is outlined in figure \ref{fig:3-somax-generate}

\section{Triggers}\label{sec:3-generate-triggers}
While the concept of a continuous audio/midi stream is rather self-explanatory, the concept of a continuous trigger stream might need some explanation. Similarly to a continuous midi stream, a trigger stream is a stream of discrete events occurring at a time $t^{(\mathcal Y)}_w$, but without any external information. In other words, the behaviour is that of a signal telling the system when to generate output.

In practice, the trigger stream is often correlated to the influencing audio/midi stream, either by midi note onsets, beat onsets or pitch detection onsets (for more details, see \cite{borg_2019}) depending on the mode of the system, but may also be completely decorrelated to incoming influences. This behaviour depends on the mode of the system, which is discussed in \cite{somaxsoftware2021}. In all cases, influencing and generating operate interleaved along the same time axis, so the behaviour of $t^{(\mathcal Y)}_w$ is similar to the behaviour of $t^{(\mathcal K)}_v$.


\section{Collecting, Scaling and Merging Peaks}\label{sec:3-generate-merge}
When a trigger is received, the first step is to collect and scale the peaks from all layers $r = 1, \dots, R$. Each layer will have a designated weight $\alpha^{(r)}$ to scale the scores of each layer, i.e.
\begin{align}
	\bm P^{(r)}_w = \begin{bmatrix} 1 & 0 \\ 0 & \alpha^{(r)} \end{bmatrix} \bm P^{(r)}_v,
	\quad r = 1, \dots, R
\end{align}
where $\bm P^{(r)}_v$ here denotes the peak matrix generated by the most recent influence step $v$.

The scaled peaks $\bm P^{(r)}_w$ from all layers $r=1,\dots R$ are then gathered into a single matrix where any peaks that occur sufficiently close to each other in corpus time $t^{(\mathcal C)}$ are summed, i.e.
\begin{align}\label{eq:3-generate-interpolation}
	\bm p_i = \begin{bmatrix} t^{(\mathcal C)}_i \\ y_i + y_j \end{bmatrix} \quad \text{if} \quad \left\lvert t_i^{(\mathcal C)} - t_j^{(\mathcal C)} \right\rvert < \varepsilon \quad \forall \bm p_i, \bm p_j \in \bm P_w,
\end{align}
for some interval $\varepsilon$, where 
\begin{align}
	\bm P_w = \begin{bmatrix} \bm P^{(1)}_w & \dots & \bm P^{(R)}_w \end{bmatrix}.
\end{align}
As the number of peaks $n_w$ at the time at index $w$ after $v$ influences has a theoretical worst case of $n_w = \mathcal{O}\left(vRU\right)$, some optimization is required to solve equation \ref{eq:3-generate-interpolation}, which by default has a time complexity of $\mathcal O \left(n^2_w\right)$. In practice, this is solved in linear time by multiplying the transposed peaks with a binary interpolation matrix $\mathcal I \in \mathbb Z_{[0,1]}^{m\times n}$ with $m = \lfloor 1/\varepsilon \rfloor$ rows and $n_w$ columns, and selecting all non-zero columns from the transposed output, i.e.
\begin{align}
	\bm\Pi_w &= \mathcal{I} \bm P_w^T \\
	\bm{P}_w &:= \left(\bm \Pi_w^T\right)_{\colon, \, y\ne 0}
\end{align}
where
\begin{align}
	\left(\mathcal I\right)_{i, j} = \left\lbrace\begin{array}{lcl}
		1 & \text{if} & \left\lfloor \frac{t_j^{(\mathcal C)}}{\varepsilon t_U^{(\mathcal C)}}\right\rfloor = i\\
		0 & \text{otherwise} &
	\end{array}\right.
\end{align}
resulting in a single merged peak matrix $\bm{P}_w \in \mathbb R^{2\times \hat n_w}$, $\hat n_w \le n_w$ for the time step at index $w$.


\section{Scaling Peaks Again - Fuzzy Filtering}\label{sec:3-generate-scale}
In section \ref{sec:3-generate-merge}, all peaks in each layer were scaled uniformly by a weight. Once merged, the peaks are scaled again with respect to a set of more elaborate algorithms $\left\lbrace \Gamma^{(1)}, \dots, \Gamma^{(J)}\right\rbrace$, based on the time of influence, each peak's corresponding corpus data and/or previously output slices, i.e.
\begin{align}\label{eq:3-peak-scaling-generic}
	\bm P_w := \Gamma^{(j)}\left(\bm P_w	, t^{(\mathcal Y)}_w, \mathcal C, \left\lbrace \mathcal S^{(\mathcal Y)}_{w-1}, \mathcal S^{(\mathcal Y)}_{w-2},\dots\right\rbrace\right) \quad \forall j = 1,\dots,J
\end{align}
where\begin{align}
	\Gamma^{(j)}\colon \bm P_x \rightarrow \bm P_z, 
	\quad \bm P_z \in \mathbb R^{m_x\times n_x}.
\end{align}
This behaviour can be seen as a sort of fuzzy filtering, as opposed to the binary matching provided by each classification/model-layer, to further emphasize or de-emphasize peaks with regards to parameters that may be difficult to classify in a meaningful manner. 


\section{Generating Output}\label{sec:3-generate-output}
Finally, the output for the time step at index $w$ is selected from $\mathcal C$ as the slice closest to the peak $\bm p_i \in \bm P_w$ with the highest score $y_i$, i.e.
\begin{subequations}
\begin{align}\label{eq:3-generating-output}
	\bm{\hat p}_w = \begin{bmatrix} \hat t^{(\mathcal C)} & \hat y \end{bmatrix}^T &= \left\lbrace \bm p_j \mid \forall \bm p_i \in \bm P_w \colon y_j \ge y_i \right\rbrace,
\end{align}
\begin{align}
	\mathcal S^{(\mathcal Y)}_w &= \underset{\mathcal S^{(\mathcal C)}_u \in \mathcal C}{\text{min}} \left \lvert \hat t^{(\mathcal C)} - t^{(\mathcal C)}_u \right\rvert.
\end{align}
\end{subequations}
If multiple vectors $\bm p_j$ fulfil the condition in equation \ref{eq:3-generating-output}, a single one will be selected randomly. If on the opposite no vectors fulfil this condition, i.e. if the peak matrix $\bm P_w$ is empty, the slice $\mathcal S^{(\mathcal C)}_{u+1}$ following the previously output slice will be used for output, i.e. given 
	\begin{align}
		\mathcal S^{(\mathcal Y)}_{w-1} = \mathcal S^{(\mathcal C)}_u
	\end{align}
	for some $u \in [1, U]$, we get
	\begin{align}\label{eq:3-generating-default-output}
		S^{(\mathcal Y)}_w = \mathcal S^{(\mathcal C)}_{u +1}.
	\end{align}