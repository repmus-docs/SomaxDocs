\chapter{The Python Architecture}\label{sec:2-python-architecture}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OVERVIEW 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}\label{ssec:2-overview}
The Python code base is the back-end of Somax and contains all of the generative aspects of the system, including modelling and classification, the implementation of the corpus and associated descriptors, scheduling and temporal behaviours, etc. The Python code base interacts with the Max front-end through OSC, where the Max front-end mainly handles real-time audio analysis and rendering, along with relevant visualization, as well as providing the user with an interface and/or GUI for interaction, but everything else is handled in Python.

A class diagram for the entire Python architecture is available in appendix \ref{sec:a-class-diagram}, and parts of this class diagram will be used throughout this chapter to illustrate certain parts of the architecture.

This chapter is divided into a number of sections, each outlining different aspects of the software architecture. Section \ref{ssec:2-io-parsing} describes the entry points into the application and how the OSC communication and interaction between the core elements work, section \ref{ssec:2-corpus} explains the architecture of the corpus, section \ref{ssec:2-scheduling} explains all aspects of the back-end related to time and scheduling, section \ref{ssec:2-player} describes the architecture of the \texttt{Player}, i.e. the class that is responsible for the modelling of the corpus and matching influences, and finally section \ref{ssec:2-compilation} will describe the current procedure of compiling the Python code into a standalone application for distribution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Associated Libraries}\label{ssec:2-librarybranches}
In addition to standard dependencies (such as Librosa, Numpy, Scipy, etc., see \texttt{python/somax/requirements.txt} for a full list), there are two external libraries that were developed within the team specifically for the needs of Somax and its related DICY2 library \cite{nika2016thesis}, \cite{nika2022dicy2}. These are the MaxOSC library \cite{maxoscrepo} and the GIG library \cite{gigrepo}. 



\subsubsection{The MaxOSC Library}\label{ssec:2-maxosc}

The MaxOSC library was developed early in the 2.0 beta phase of Somax with the intention of facilitating OSC communication between Max and Python. It contains a number of classes for exposing a Python class' member functions so that they are directly callable over OSC using a Python-like syntax, as well as adding support for more complex types than the ones supported by the OSC protocol \cite{osc2022} (such as nested lists, hash maps, etc.)

The MaxOSC library was initially developed as two sister libraries: MaxOSC, the Python library described above, and PyOSC, a set of Max objects for facilitating the interaction in Max.\footnote{Note that the name of the python repository is \texttt{pyosc} for this reason, but only the subfolder \texttt{maxosc} is currently used in Somax} The latter was revisited during the work on the \cite{gigrepo} (described below) and new externals for synchronous as well as asynchronous OSC calls to a remote, hierarchical class architecture\footnote{See the \texttt{dev-connector-singleton} branch of the \texttt{pyosc} repository}, were developed, but ultimately not used in the current version of as the development of Somax took a different turn when the development of DICY2 ceased. The MaxOSC library is available on PyPI and can be installed directly through \text{pip}.


\subsubsection{The GIG Library}\label{ssec:2-gig}

The GIG library \cite{gigrepo} was developed in 2022 with two goals in mind. Firstly, to provide a unified architecture for Somax and DICY2 so that research and improvements in either of the two would benefit the other, as well as ideally merge the two into a single framework of generative agents. Secondly, to use our experiences of working with the libraries to unify and solve a number of architectural issues with the current implementations, as well as to  generalize a number of functionalities (such as OSC parsing, scheduling, classification, corpus building, etc.) and thereby provide easy-to-use classes that could be used in future projects. 

Ultimately, the GIG library was not put to use in Somax as it was abandoned when the DICY2 development came to a halt, but it is referenced frequently in this report, as it provides solutions to a number of problems that still exist in the current code base of Somax, and could be used as a future reference. The rewritten version of Somax, based on the GIG library, is available on the \texttt{dev-merge-osc} branch of the Somax2 repository.

The GIG library is currently not available on PyPI, but it can be imported as a git submodule. See the \texttt{Dicy2-python} repository \cite{dicy2pythonrepo} for reference on how to use it.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% INPUT/OUTPUT & PARSING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Input/Output \& Parsing}\label{ssec:2-io-parsing}
When using Somax with the Max front-end, the \texttt{somax\_server.py} file contains the \texttt{main} function, and once launched, any other communication will be handled solely through OSC. The \texttt{main} function instantiates the \texttt{SomaxServer} class, which corresponds to the \texttt{somax.server} object in Max (see section \ref{ssec:3-server}).

The \texttt{SomaxServer}'s main role is to manage the application's \texttt{OscAgent}s, where each \texttt{OscAgent} corresponds to a \texttt{somax.player} object (see section \ref{ssec:3-player}). It's also responsible for the \texttt{Transport} object, which is the clock that synchronizes time between all the different players (this will be further described in section \ref{ssec:2-scheduling}). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{AsyncioOscObject}

Both the \texttt{SomaxServer} and \texttt{OscAgent} inherit from the \texttt{AsyncioOscObject}, which is the class responsible for all OSC handling. This class uses an \texttt{asyncio}-based \cite{pyasyncio2021} UDP server for handling messages sent from the Max front-end, which means that it's able to have zero or more runtime callbacks that are processed in parallel with OSC I/O operations. Note that while \texttt{asyncio} in some sense allows us to write concurrent code, it's still effectively single-threaded, so there's no need to worry about race conditions, data races or other parallelism-related issues. This applies to all of the Somax library: while it relies on several parallelism-oriented libraries (both multiprocessing \cite{pymultiproc2021} and asyncio), it's designed so that no resources ever are shared and each component of the system can always be treated as if it was single-threaded.

The \texttt{AsyncioOscObject} inherits from the \texttt{Caller} class of the \texttt{maxosc} package, which automatically exposes all function of the class (and any class inheriting from it) so that it can be called directly over OSC using a python-like syntax. For example, a function like

\begin{lstlisting}
def create_agent(self, 
                 name: str,
                 recv_port: int, 
                 send_port: int,
                 ip: str = "",
                 override: bool = False)
\end{lstlisting}
can be called over OSC using any of the following messages

\begin{lstlisting}
/somax create_agent "Player1" 1234 1235 "127.0.0.1" 1
/somax create_agent name= "Player1" recv_port= 1234 send_port= 1235 override= 1
/somax create_agent name="Player1" recv_port=1234 send_port=1235 override=True
/somax create_agent "Player1" 1234 1235 override= 1
\end{lstlisting}
In other words, the syntax is similar to how a Python function normally is called but adapted to a Max environment (using spaces rather than commas, allowing spaces between argument names and values, e.g. \texttt{recv\_port= 1234} rather than \texttt{recv\_port=1234}, to avoid having to use the \texttt{combine} object in Max for named arguments, etc.) It's also possible to pass nested lists and/or dictionaries from Max with a Python-like syntax. e.g. for some Python function \texttt{f} that accepts nested lists, any of the following calls from max would be valid:

\begin{lstlisting}
	/somax f []
	/somax f [ 1 2 3 4 ]
	/somax f [1 2 3 4]
	/somax f [ [1 2] [3 4] [ 5 6 ]]
\end{lstlisting}
Note that the OSC address is not used at all (it's \texttt{/somax} for all calls to the \texttt{SomaxServer} and the name of the agent for any call to a \texttt{OscAgent}, but both of these are redundant as each server and agent uses its own set of ports). This is because the underlying \texttt{python-osc} library does not support adding OSC addresses dynamically through OSC calls (e.g. if we want to create an agent \texttt{agent1} at address \texttt{/somax/agent1} through the \texttt{create\_agent} function called over OSC, this will simply not work using the \texttt{python-osc} library).

The \texttt{\_main\_loop} function is the only abstract function of the \texttt{AsyncioOscObject}. In the \texttt{SomaxServer}, this is implemented as a dynamic variable \texttt{self.loop}, which is bound either to the \texttt{\_\_master\_loop} or \texttt{\_\_slave\_loop} functions. At the moment, only the \texttt{\_\_master\_loop} is used, but the \texttt{\_\_slave\_loop} function was added in order to allow synchronizing the transport of the \texttt{SomaxServer} to an external clock, for example the Live transport (if using Somax in Max for Live device) or a transport in Somax. This is however not exposed in the front-end (i.e. the Max \texttt{somax.server} object) at the moment.

Also note that an improved version of the \texttt{AsyncioOscObject} exists in the GIG library (there called \texttt{AsyncOsc}), which has a number of subclasses for handling different types of async OSC communication.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{SomaxServer \& OscAgent}\label{ssec:2-server-agent}
The central class of the Somax library is the \texttt{OscAgent}, which, as mentioned above, corresponds to the \texttt{somax.player} object. The \texttt{OscAgent} is initialized through the \texttt{SomaxServer}, but once initialized, the \texttt{somax.player} and \texttt{OscAgent} communicate directly through their own set of OSC ports. This class is responsible for handling all input/output to the \texttt{Player} (such as influences, output requests, setting parameters, etc.), as well as the co-ordinating time management between the \texttt{SomaxServer} and the \texttt{Player}, which is managed through the \texttt{SchedulingHandler}.

The \texttt{OscAgent} inherits from \texttt{multiprocessing.Process} class, which essentially is a way to bypass the global interpreter lock (GIL) in Python by running each \texttt{OscAgent} in its own subprocess rather than its own thread. Communication between the \texttt{OscAgent} and \texttt{SomaxServer} is handled through a \texttt{multiprocessing.Queue}, essentially a two-way pipe which passes \texttt{ProcessMessage}s between the two objects. Almost all of the communication are messages related to time and scheduling and will be described in section \ref{ssec:2-scheduling}\footnote{The only exceptions are the \texttt{PlayControl.CLEAR} and \texttt{PlayControl.TERMINATE} messages of the \texttt{ControlMessage} class, which calls \texttt{OscAgent.clear()} and \texttt{OscAgent.terminate()} functions accordingly.}.

The \texttt{SomaxServer} owns the \texttt{OscAgent}s and is responsible for joining their processes once finished (e.g. when the server is shut down or if the \texttt{somax.player} is deleted in Max). In addition, the \texttt{SomaxServer} is also managing the \texttt{CorpusBuilder}s, which will be launched as separate \texttt{multiprocessing.Process}es when the user is building a corpus (in order to not block the \texttt{Transport} while building corpora). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The Target class}\label{ssec:2-target-class}

Any output from the \texttt{OscAgent} and \texttt{SomaxServer} classes (i.e. messages to the front-end) are sent through the \texttt{Target} class, which is a light wrapper around the \texttt{pythonosc} UDP client (with some formatting for Max compatibility). In other words, all OSC communication is handled by the \texttt{OscAgent} and \texttt{SomaxServer} classes, so these are the only two classes one needs to understand to fully understand all supported IO operations\footnote{There's one slight exception to this rule: the \texttt{ThreadedCorpusBuilder}. Once the process of building a corpus through the \texttt{ThreadedCorpusBuilder} has been launched, it does not communicate with the \texttt{SomaxServer}, but its return value, which is either the path of the built corpus or an error message, is sent through its own \texttt{Target}, which however is using the same ports as the \texttt{SomaxServer} and hence received directly by the \texttt{somax.server}'s \texttt{udpreceive} object.}. 

The \texttt{Target} will, just like the \texttt{AsyncioOscObject} return messages to a the same static OSC addresses mentioned above, and rather use a keyword for the OSC messages to the Max front-end (which is the common practice in Max). All of the keywords for the OSC messages sent from the \texttt{SomaxServer} and \texttt{OscAgent} are stored in the \texttt{ServerSendProtocol} and \texttt{PlayerSendProtocol} respectively. In other words, the entire protocol for OSC messages sent from the back-end to the front-end can be understood by reading through these two classes.\footnote{Similarly, the entire protocol for OSC messages from the front-end to the back-end can be understood by reading the function signatures of the \texttt{SomaxServer} and \texttt{OscAgent} classes.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parsing \& Exception Handling}\label{ssec:2-parsing-introspective}
As the \texttt{SomaxServer} and \texttt{OscAgent} classes are handling all I/O operations, they are also responsible for parsing the messages and ensuring that no invalid messages are accepted. 

The Somax Python library relies heavily on type annotations, and will generally not check whether the correct type is passed; this is rather left to the developer/user to handle ("We're all consenting adults here", as the Python mantra goes). The one exception to this rule are the \texttt{SomaxServer} and \texttt{OscAgent} classes, as these handle input directly from a user in Max (through the \texttt{somax.server} and \texttt{somax.player} objects), who we cannot assume is necessarily passing the correct information, and who will need proper error messages posted in the Max console, rather than cryptic Python exceptions, when the wrong type of information is sent. Therefore, the \texttt{SomaxServer} and \texttt{OscAgent} have very strict type and bounds checking.

A number of functions in the \texttt{OscAgent} also makes frequent use of the fact that introspection is possible in Python. As many components of the Somax architecture are modular (\texttt{AbstractScaleAction}, \texttt{AbstractClassifier}, \texttt{AbstractActivityPattern}, etc.), Any class whose base class is inheriting from the \texttt{StringParsed} class can be parsed directly from a string corresponding to the class' name, assuming that they are located in the same module. For example

\begin{lstlisting}
>>> AbstractScaleAction.from_string("nextstatescaleaction")
<somax.runtime.scale_actions.NextStateScaleAction object at 0x..>
\end{lstlisting}
This means that new classes can be added in the same module and be fully accessible through the OSC protocol without changing any part of the code related to the parsing. The only exception to this strategy is the \texttt{FeatureValue} class, where new features need to be added to the \texttt{somax/features/\_\_init\_\_.py}, as the classes to parse are spread over several modules.

Finally, it's worth noting that the \texttt{SomaxServer} is actually split in two classes: \texttt{Somax} and \texttt{SomaxServer}, and similarly the \texttt{OscAgent} in \texttt{Agent} and \texttt{OscAgent}. The intention with this distinction was to separate the parsing/OSC handling into a separate class, so that the \texttt{Agent} and \texttt{Somax} classes could be used directly in Python. The current separation is however not used and largely irrelevant — a proper and clean separation of the two can instead be found in the (abandoned) \texttt{dev-merge-osc} branch.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Parametric \& Parameter}\label{ssec:2-parameters}
The final aspect of the I/O and parsing is the \texttt{Parametric} class. Since the configuration of the \texttt{Player} can change dynamically by adding/removing \texttt{Atom}s, \texttt{ScaleAction}s, etc. it's necessary to be able to address parameters of said classes dynamically so that they can be changed from the front-end. This is handled by the \texttt{Parametric} and \texttt{Parameter} classes. The relationship between the two can be seen as a tree where \texttt{Parametric} are the branch nodes and \texttt{Parameter} are the leaf nodes, where the value of a \texttt{Parameter} can be set by addressing its position in the tree. For example, given a \texttt{Parameter} \texttt{ngram\_length} of the \texttt{NGramMemorySpace} (which inherits from the \texttt{Parametric} class, where the latter is owned by an \texttt{Atom} of the player (also inheriting from the \texttt{Parametric} with the name \texttt{melodic}, the value of this parameter can be set by calling the \texttt{Player}'s \texttt{set\_param} function:
\begin{lstlisting}
/agent1 set_param melodic::_memory_space::_ngram_size 3
\end{lstlisting}
Note that the parameter tree needs to be re-computed when any \texttt{Parametric} (for example a \texttt{ScaleAction}) is added or removed. This is done through the \texttt{Parametric.parse\_parameters} function.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% THE CORPUS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Corpus}\label{ssec:2-corpus}
TODO: how to implement new features

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SCHEDULING
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Scheduling}\label{ssec:2-scheduling}
One of the most important responsibilities of the Python back-end is to manage time and scheduling. The current time, represented by a \texttt{Time} object, is managed by the \texttt{Transport} in the \texttt{SomaxServer}, and is synchronized between all \texttt{OscAgent}s. The \texttt{Transport} is polled each millisecond in the \texttt{SomaxServer.callback()} function to update the \texttt{Time}, and then sends it to each existing \texttt{OscAgent} through its associated \texttt{multiprocessing.Queue} (see section \ref{ssec:2-server-agent}). The \texttt{OscAgent} has its own \texttt{\_main\_loop} function where it receives these messages and updates time accordingly through its \texttt{Scheduler}. The current time is through the \texttt{Time} object represented both in ticks (where 1.0 ticks corresponds to one quarter note) and seconds, and has an associated tempo.

The \texttt{Transport} and \texttt{Scheduler} manage two different responsibilities: the \texttt{Transport} is the internal clock of the system, which manages how much time has elapsed since the previous callback, while the \texttt{Scheduler} is responsible for when each event should happen.

The \texttt{OscAgent} does not communicate directly with the \texttt{Scheduler}; the \texttt{OscAgent} has a \texttt{SchedulingHandler}, which has a \texttt{Scheduler}. The \texttt{SchedulingHandler} is an abstract base class with a number of different implementations, where the different implementations roughly corresponding to the \texttt{mode} attribute in the \texttt{somax.player} object, and is described in section \ref{ssec:2-scheduling-handler}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{ScheduledEvent}\label{ssec:2-scheduled-event}
The \texttt{Scheduler} only accepts a single type of message: the abstract \texttt{ScheduledEvent} class, which has a \texttt{trigger\_time}, which determines when the event should be output by the \texttt{Scheduler}. There are four main types of \texttt{ScheduledEvent}s:

\begin{description}
	\item[\texttt{TriggerEvent}] When output, triggers output by the \texttt{Player} through the \\\texttt{OscAgent.\_trigger\_output} function.
	\item[\texttt{RendererEvent}] Contains OSC messages that will be sent directly to Max to trigger rendering of some sort (example subclasses are \texttt{MidiNoteEvent}, \texttt{AudioEvent}, \texttt{AudioOffEvent}, etc.)
	\item[\texttt{TempoEvent}] Contains information about the last played \texttt{CorpusEvent}s annotated tempo. If the \texttt{OscAgent} is set as the \texttt{SomaxServer}'As tempo source, it will send this message through the \texttt{multiprocessing.Queue} back to the server to set its tempo. If not, it will simply be ignored
	\item[\texttt{ContinueEvent}] When output, triggers output by the \texttt{Player} through the \\ \texttt{OscAgent.\_continue\_output} function. The difference between \texttt{TriggerEvent} and \texttt{ContinueEvent} is described in section \ref{ssec:2-timeout}.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The SchedulingHandler}\label{ssec:2-scheduling-handler}
The \texttt{SchedulingHandler}'s main role is to receive \texttt{CorpusEvent}s, convert them into the appropriate \texttt{ScheduledEvent}s and schedule them accordingly through its internal \texttt{Scheduler}, which is handled by the \texttt{SchedulingHandler.add\_corpus\_event} function. When triggering output from a \texttt{somax.player} object in Max (e.g. through a \texttt{bang} or a \texttt{influence onset} message, which both call the \texttt{OscAgent.bang} function), this does not directly trigger output but rather schedules a \texttt{TriggerEvent} through the \texttt{SchedulingHandler.add\_trigger\_event} function. There are currently three different \texttt{SchedulingHandler}s with three different behaviours for \texttt{add\_corpus\_event} and \texttt{add\_trigger\_event}:

\begin{description}
	\item[AutomaticSchedulingHandler] Plays continuously by immediately scheduling a new \texttt{TriggerEvent} at the end of each \texttt{CorpusEvent} received. Any manual triggers called through the \texttt{add\_trigger\_event} will be ignored. This class corresponds to \texttt{@mode continuous} in the Max front-end.
	\item[ManualSchedulingHandler] Schedules a single \texttt{TriggerEvent} immediately when the \texttt{add\_trigger\_event} is called, thereby interrupting any currently rendered events. Does not reschedule any \texttt{TriggerEvent}s on \texttt{add\_corpus\_event}. This class corresponds to \texttt{@mode reactive} with \texttt{@cut 1} in the Max front-end.
	\item[IndirectSchedulingHandler] Schedules a single \texttt{TriggerEvent} immediately when the \texttt{add\_trigger\_event} is called, unless it is in the middle of rendering an event, in which case it will schedule the trigger at the end of the current event. This class corresponds to \texttt{@mode reactive} with \texttt{@cut 0} in the Max front-end.
\end{description}
Note that while neither the \texttt{ManualSchedulingHandler} nor the \\ \texttt{IndirectSchedulingHandler} will ever reschedule any triggers, they may still continue playing further events due to the \texttt{ContinueEvent}. These behaviours are explained in section \ref{ssec:2-timeout}.

The process of converting an \texttt{CorpusEvent} into a set of \texttt{RendererEvent}s is handled by the \texttt{AudioStateHandler} (for an \texttt{AudioCorpusEvent}) and the \texttt{MidiStateHandler} (for a \texttt{MidiCorpusEvent}) classes. These classes are responsible for behaviours strictly related to the rendering, for example whether an audio renderer needs to jump in the buffer or may continue playing linearly, or in the MIDI case, to handle note offs, notes sustained over several slices, etc.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Synchronization \& Time Stretch}\label{ssec:2-time-stretch}

Due to the separation between time management (\texttt{Transport}) and scheduling \\ (\texttt{Scheduler}), time stretch is fairly simple to achieve, we can just apply a time stretch factor to the time received from the \texttt{Transport} and the scheduling will automatically adapt to the new, stretched tempo, assuming that we output the same information to the renderer. A naive approach would be
\begin{align}
	t_\text{stretch}[n] = t_\text{transport}[n] \cdot \gamma
\end{align}
where $n \in \mathbb Z_+$ indicate the current step in the callback, $t_\text{stretch}[n] \in \mathbb R_+$ the stretched time at step $n$, $t_\text{transport}[n] \in \mathbb R_+$ the \texttt{Transport}'s time at step $n$ and $\gamma \in \mathbb R_+$ is the time stretch factor (i.e. 1.0 means no time stretch, 0.5 half the speed, 2.0 double the speed, etc.). Since the user may change $\gamma$ over time, this would however produce discontinuities in time. To avoid this, we'll calculate the discrete integral over $t_\text{transport}$, i.e.
\begin{align}\label{eq:2-timestretch}
	t_\text{stretch}[n] = 	t_\text{stretch}[n-1]  + \left(t_\text{transport}[n] - t_\text{transport}[n-1]\right)\cdot \gamma[n]
\end{align}
where $\gamma[n]$ now indicates the current time stretch value set by the user at step $n$. 

All of this is handled in the \texttt{SchedulingHandler}, and the time stretch factor can be set with the \texttt{SchedulingHandler.set\_time\_stretch\_factor} function. There's however another way of achieving time stretch: by changing the server's (or more specifically, the \texttt{Transport}'s) tempo.

There are currently two modes for scheduling in Somax (super class \texttt{SchedulingMode}): 
\begin{description}
	\item[\texttt{RelativeScheduling}] events are scheduled in ticks,
	\item[\texttt{AbsoluteScheduling}] events are scheduled in seconds. 
\end{description}
In relative time, which is only used by MIDI corpora, changes to the server's tempo will naturally result in changes to the playback speed, as one tick corresponds to a quarter note, the duration (in seconds) of a tick changes with the tempo. In absolute time, changes to the tempo will not change the playback speed (a second is still a second). Audio corpora only have absolute time, but may still adapt to the tempo of the server by computing the difference between its annotated tempo and the server's tempo, and adjusting the time stretch factor accordingly. The choice between the different \texttt{SchedulingMode}s is not directly controlled by the user, but a result of whether the user chooses to synchronize to the server's tempo or to use a manual time stretch factor, as controlled by the \texttt{OscAgent.set\_synchronize\_to\_global\_tempo} function. In summary, we have four different cases:

\begin{description}
	\item[Audio corpus, synchronize=False] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ directly controlled by the user
	\item[Audio corpus, synchronize=True] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ calculated as the quotient between the server's tempo and the last rendered \texttt{AudioCorpusEvent}
	\item[MIDI corpus, synchronize=False] \texttt{AbsoluteScheduling} according to equation \ref{eq:2-timestretch} with $\gamma$ directly controlled by the user
	\item[MIDI corpus, synchronize=True] \texttt{RelativeScheduling} without any time stretch factor.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Timeout \& Continue}\label{ssec:2-timeout}













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% THE PLAYER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Player}\label{ssec:2-player}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% COMPILATION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Compilation}\label{ssec:2-compilation}

