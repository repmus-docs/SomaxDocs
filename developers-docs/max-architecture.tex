\chapter{The Max Architecture}\label{sec:3-max-architecture}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OVERVIEW
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Overview}\label{ssec:3-overview}
The Somax Max package is responsible for two things: It serves as the front-end/API for the end user and it's responsible for handling every aspect of real-time signal processing. Everything else is handled by the Python code base. 

At the core of the Max package are the \texttt{somax.server} and \texttt{somax.player} objects, both which are essentially wrappers around one pair of \texttt{udpsend}-\texttt{updreceive} each, through which they manage all communication with their corresponding \texttt{SomaxServer} and \texttt{OscAgent} Python objects respectively. These two objects have been designed with a single goal in mind: to behave as if they were native Max objects.

One explicit requirement for the entire project has been that as much of the code as possible should be written only in Python and Max. Since Somax is a research project, it was considered likely that future members and developers on the team mainly would have experience with Python and Max, and that it for this reason could  be difficult to maintain the code in the future if a significant portion of it was written in C/C++.

For this reason, the entire Max part of the Somax code base has been written as abstractions rather than externals. While this does increase the transparency for Max developers, it comes with a number of downsides that all make the above mentioned goal more difficult, that will be discussed thoroughly in this chapter. 

This chapter assumes that the reader has good knowledge of Max and will not explain basic aspects of Max that it frequently relies on (e.g. \texttt{pattr}, \texttt{bpatchers}, the distinction between \texttt{patchers} and \texttt{abstractions}, the Max threading model, etc.), but rather focus on the code base itself in order to give an overview

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The Max Package's Structure}\label{ssec:3-structure}
The Somax package consists of more than 50 abstractions, but most of them are used internally in a few core object, rather than being relevant for the end user. In this chapter, we will only focus on these core objects, as most of the abstractions can easily be understood from their corresponding contexts.

\noindent The base objects of the package are: 

\begin{description}
	\item[\texttt{somax.server}] which handles the communication with the Python server
	\item[\texttt{somax.player}] which handles the communication with a particular \texttt{OscAgent} on the server
	\item[\texttt{somax.audiocorpusbuilder}] which is the front-end to the \texttt{CorpusBuilder} when used to create a \texttt{Corpus} from an audio file
	\item[\texttt{somax.midicorpusbuilder}] which is the front-end to the \texttt{CorpusBuilder} when used to create a \texttt{Corpus} from a MIDI file
	\item[\texttt{somax.audioinfluencer}] which is used to analyze a real-time signal in the same manner as the \texttt{Corpus} is analyzed when built, segmenting the signal into discrete, symbolic data that are used to influence the \texttt{Player}
	\item[\texttt{somax.midiinfluencer}] same as above but for real-time MIDI streams
	\item[\texttt{somax.audiorenderer}] which converts the symbolic messages received from the \texttt{OscAgent} into real-time audio data when using an audio \texttt{Corpus}
	\item[\texttt{somax.midirenderer}] same as above for a for an \texttt{OscAgent} with a MIDI \texttt{Corpus}.
\end{description}

\noindent These objects are intended for any user who wishes to use any part of the Somax library in a modular manner. Two further variations exist for a number of those objects. \texttt{somax.<object>.ui} and \texttt{somax.<object>.app}. The former is for each object just a condensed UI suitable for using in a bpatcher, but in terms of messages and functionality identical to the core objects. The latter set of objects are application-style bpatcher objects designed for users with little or no experience in Max, where all of the functionality, including input and output, is encapsulated, with little room for the user to customize the design/behaviour of the object. The \texttt{.ui} objects that exist are \texttt{somax.player.ui}, \texttt{somax.audioinfluencer.ui} and \texttt{somax.midiinfluencer.ui}. The \texttt{.app} objects that exist are \texttt{somax.player.app}, \texttt{somax.server.app}, \texttt{somax.audioinfluencer.app} and \texttt{somax.midiinfluencer.app}. The latter set of objects will be further described in section \ref{ssec:3-app-objects}, while all other sections mainly will focus on the base objects (i.e. the objects with neither an \texttt{.ui} nor \texttt{.app} extension).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Design Guidelines}\label{ssec:3-design-guidelines}
To achieve the goal mentioned above, i.e. that all base objects should behave as if they were native Max objects, or more specifically as if they were well-designed, compiled externals, the following set of guidelines were developed:

\subsubsection{Clear Separation Between Attributes and Messages}
An attribute of an object is a setting or property that tells the object how to do its job. While this is a fundamental principle of modern Max objects, it's quite difficult to achieve for objects whose state actually is stored on a remote server, that may or may not have been started when the object is created. This will be discussed in section \ref{ssec:3-osc-issues}.

In addition, passing attributes to abstractions comes with a number of issues in Max, which will be discussed in section \ref{ssec:3-abstractions}

\subsubsection{Errors Should Be Explicit}
Passing incorrect messages, values of the wrong type or attributes that don't exist to an object should always produce an explicit error (typically printed to the Max console), and if the message is an important part of a control flow that the user may rely on, the object should output a message or error code to indicating the error, so that the user can react accordingly. For example, if the \texttt{somax.audiocorpusbuilder} fails to build a corpus, a message indicating what went wrong will be printed in the Max console as well as the error code being output on the first outlet of the \texttt{somax.audiocorpusbuilder}, so that the user is able to react programmatically when this happens.


\subsubsection{All Attributes Should Be Exposed to Pattr}
Any attribute that the user may want to control should be exposed to the Max \texttt{pattr} system in order to allow the user to store, load and interpolate between states and configurations of the different objects.

\subsubsection{Avoid Global State}
The usage of global state (such as global \texttt{value}, \texttt{send} and \texttt{receive}, \texttt{dict} and \texttt{coll}, etc.) should be avoided at all costs and only used when absolutely necessary. By global, we mean state that is shared outside of a given abstraction, i.e. any send/receive/dict/etc. without \texttt{\#0} in its name. The reason for this is simple: global state makes the code so much more difficult to read. 

With that said, there are still a number of cases where global state is necessary in the Somax library. These will be discussed in section \ref{ssec:3-global-state}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{OSC Communication Issues}\label{ssec:3-osc-issues}
All of the communication between Max and Python is handled through (UDP-based) OSC. There are several benefits of choosing UDP-based OSC, it's efficient for real-time messaging and it's compatible with a number of different environments (most programming languages and music-oriented coding environments have actively maintained OSC modules). But most of its downsides are highly problematic for our use case: the fact that we cannot be sure whether the message was received, that there's no synchronous sending in Max, that messages may get silently dropped if the socket is full, and finally that we cannot send objects larger than a couple of kilobytes (size varies slightly between implementations).

Most of these issues are however only problematic in the initialization step, when establishing a connection between Max and Python, creating the remote representations of the \texttt{somax.player} and loading a corpus. For runtime messages, if a message should be dropped, this would in the absolute worst case result in a second or two of silence (which likely would sound like a musical pause), but in most cases, it wouldn't have any real consequences at all. For the initialization, however, there are a number of things that could go wrong. For example, if a user sends a message from Max to a remote \texttt{Player} (for example setting a certain parameter) while the remote \texttt{Player} still is in the middle of initializing and has yet to establish the UDP connection, the message sent by the user will be dropped and there's no way for the user to know that this has happened. This means that the UI in Max will indicate one value but the actual value used by the remote \texttt{Player} is another. 

Now, one could claim that it's perfectly legitimate to assume that the user would understand that it's not possible to set parameters until the initialization of the remote \texttt{Player} is complete, and while this is true to some extent, it would make the objects cumbersome to use in Max, as it wouldn't be possible to rely on normal initialization / control flow mechanics in Max such as attributes, loadbangs or pattr, and the it would be important to manually keep track of the order that the messages are sent in, thus departing far from the standards of Max programming.

With this in mind, the objects that rely on communication with the remote Python server (i.e. the \texttt{somax.server} and \texttt{somax.player} objects in Max) have been designed to store its internal state inside the object as well as on the remote. This means that if the remote crashes, is restarted, or if parameters are set before the remote has been started, it's possible to just update the remote by sending the state as it has been stored in Max. This means that the objects can be used in a normal manner, where we can set any attribute at initialization independently of whether the remote is running, and then just output it after the initialization procedure has been completed. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Abstraction Issues}\label{ssec:3-abstractions}

The second main issue of the Somax library is related to the requirement of writing the Max code as abstractions rather than externals. While this comes with a number of benefits, mainly in terms of transparency for the user, the major problem with abstractions in Max is that they behave differently than externals on initialization. Consider the example in figure \ref{fig:3-abstractions-externals}. Assuming that the \texttt{myabstraction} object is an abstraction (which relies on \texttt{patcherargs} to pass attributes) and the \texttt{myexternal} is an external (where the attribute is a member variable), the value of the attribute \texttt{somevalue} will be different in these two objects. In the external object, \texttt{somevalue} will be set to 1 when the object is initialized, then immediately changed to 2 by the \texttt{loadbang}, as we expect. In the abstraction, the object will be initialized without a given value for \texttt{somevalue}, then the \texttt{loadbang} will set it to 2, followed by the deferlow'ed \texttt{patcherargs} setting it to 1. So in the object on the left, the value for \texttt{somevalue} will be 1 but in the object on the right, the value will be 2.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.7\textwidth, keepaspectratio]{figures/abstractions-externals.png}
    \caption{The abstraction inconsistency}
    \label{fig:3-abstractions-externals}
\end{figure}

\noindent Now, one could claim that this is a rather marginal case that won't be of huge importance, as you wouldn't set the attribute to one value and then immediately change it afterwards regardless. This is true for top-level objects, but becomes problematic for any nested abstraction. Consider the case in figure \ref{fig:3-nested-abstractions}. Here, \texttt{myplayer.app} is an abstraction that contains \texttt{myplayer} (among many other objects, omitted for space), where we want the default value for the attribute \texttt{mode}, when used in this particular abstraction, to be \texttt{continuous}, but the user may want to change this value immediately as part of their own configuration. If \texttt{myplayer} was an external, this would work as intended, but since \texttt{myplayer} is an external, the \texttt{patcherargs} will overwrite the user settings as sent by the \texttt{loadbang}.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.6\textwidth, keepaspectratio]{figures/nested-abstractions.png}
    \caption{Nested abstractions}
    \label{fig:3-nested-abstractions}
\end{figure}

\noindent Unfortunately, there are a number of issues related to nested abstractions, such as the difficulty to pass any number of attributes from one abstraction to another (requires nested \texttt{patcherargs} where we cannot ensure the order), the difficulty to set default arguments (passing arguments from one abstraction to another with the \texttt{\#1}-syntax will be replaced with \texttt{0} if the user doesn't provide any argument to the outer abstraction). Yet another issue is the fact that there's no way to fail initialization of the abstraction (as in figure \ref{fig:3-failed-init}) if invalid arguments are passed to the abstraction. This can be very problematic if the abstraction is manipulating some global state or performing I/O-operations. A concrete example in the Somax library would be if \texttt{somax.player} is initialized with invalid OSC ports, which unless properly handled would create the \texttt{OscAgent} on the server but then be unable to communicate with it (including deleting it). Or even worse, if its initialized with an OSC port used by another \texttt{somax.player}, which would create all sorts of issues between the two players.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.25\textwidth, keepaspectratio]{figures/failed-external.png}
    \caption{An external that failed initialization since the arguments were invalid}
    \label{fig:3-failed-init}
\end{figure}

\noindent The workaround for most of these problems lies in the \texttt{somax.await\_patcherargs} abstraction. This object is modelled on the \texttt{bach.args} object from the Bach library \cite{agostini2012bach} and will store any messages sent to the abstraction and not output them until the \texttt{patcherargs} initialization is done, hence ensuring correct initialization order. Unlike the \texttt{bach.args} object, this object will also allow explicit initialization failures if the object is initialized with invalid arguments. In this case, the \texttt{somax.await\_patcherargs} will continue to block any input to ensure that no I/O-operations or global state changes are done while the object is invalid. If the issues causing the initialization to fail are resolved, it's possible to reinitialize the object with the \texttt{reload} command.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Global State}\label{ssec:3-global-state}
While one of the main guidelines presented in section \ref{ssec:3-design-guidelines} was that global state should be avoided as much as possible, some interaction between certain objects is necessary. This could've be solved by directly connecting the objects to each other (which, in fact, was the case in early versions of Somax 2), but from a user perspective, this would've been inconvenient and difficult to understand, as it is related to internal implementation details that the user shouldn't have to be aware of. Global state is therefore used in the following cases:

\subsubsection{Initialization of server and players}
The \texttt{somax.server} and \texttt{somax.player} (or more specifically the \texttt{somax.unique\_number} abstraction inside the \texttt{somax.player.core} object) objects store their corresponding OSC ports in the global \texttt{somax.recvports}. This allows us to automatically assign OSC ports when new \texttt{somax.player}s are created, as well as ensure that if an object is created with manual ports that are already used elsewhere, the initialization will fail. Ports are removed from the dictionary when the \texttt{somax.player} or \texttt{somax.server} are deallocated.

The \texttt{somax.player} also stores its name in the \texttt{somax.players} dict (through the \texttt{somax.uniuqname} object)  to ensure that two players with the same name cannot be created on the server.

Finally, the \texttt{somax.server} stores an internal counter of the number of \texttt{somax.server} objects that currently exists in Max, to avoid duplicate servers. This is stored in the \texttt{somax.num\_servers} \texttt{value} object.

\subsubsection{Communication between server and player}
Nearly all communication between the remote \texttt{SomaxServer} and \texttt{OscAgent} (which correspond to the \texttt{somax.server} and \texttt{somax.player} objects in Max) is handled directly on the Python side, but there are a couple of cases where communication directly between the \texttt{somax.server} and \texttt{somax.player} local objects is necessary. These are:
\begin{itemize}
	\item When the remote \texttt{OscAgent} is created. This message is sent from the \texttt{somax.player} to the \texttt{somax.server}, which sends the message to the \texttt{SomaxServer} to create the \texttt{OscAgent}. 
	\item When the \texttt{somax.server} crashes or is terminated in a manner that doesn't allow the remote \texttt{OscAgent} to inform its local \texttt{somax.player} to stop playing.
	\item When the \texttt{somax.server}'s transport is started or stopped.
\end{itemize}

\noindent These messages are handled with global \texttt{send}-\texttt{receive} pairs on the addresses \texttt{somax.from\_server} for messages from \texttt{somax.server} to \texttt{somax.player}) and \texttt{somax.to\_server} for messages from \texttt{somax.player} to \texttt{somax.server}.


\subsubsection{Communication between server and corpus builder}

The \texttt{somax.midicorpusbuilder} and \texttt{somax.audiocorpusbuilder} objects do not have their own pairs of \texttt{udpsend} and \texttt{udpreceive}, but communicates through the \texttt{somax.server}. Messages from either of the local corpus builders and their remote counterparts are therefore sent through the \texttt{somax.server}, and uses the same send/receive addresses as in the above paragraph (\texttt{somax.from\_server} and \texttt{somax.to\_server}).


\subsubsection{Corpus path}
The \texttt{corpuspath} is the folder to which all corpus builders will export their corpora when built, as well as the folder where all \texttt{somax.player}s by default will search for corpora and associated audio files. The corpus path is fully managed by the \texttt{somax.corpuspath} abstraction, which internally uses the \texttt{value} object with name \texttt{somax.corpuspath} to store the corpus path, as well as \texttt{send}-\texttt{receive} address \texttt{somax.corpuspath\_update}, which triggers an update in all \texttt{somax.corpuspath} objects when the path is updated in one of them.


\subsubsection{Communication between .app objects}
Since some of the explicit requirements for the \texttt{somax.<object>.app} objects (described in section \ref{ssec:3-app-objects}) are that they should be self contained, support fully dynamic routing of influences between objects and be duplicatable without having to leave presentation mode (i.e. without having to add or remove any patch cords), global sends and receives is a must here. 

Influence messages between .app objects are are sent through the \texttt{somax.source} object (contained in any \texttt{.app} object that has an influencer) using an address specific for that particular source with the format \texttt{source.<name>} (where \texttt{<name>} is the name of the object, e.g. \texttt{Player2} or \texttt{AudioInfluencer}). These names are also stored in the dictionary \texttt{somax.sources}.

Finally, the \texttt{somax.routing} send/receive-address is used whenever a source is added or removed to update any related UI object, for example to remove the source from all associated \texttt{umenu}s if the source is deleted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SERVER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The Server Object}\label{ssec:3-server}

From a development point of view, the \texttt{somax.server} object has five different phases: (1) object initialization, (2) remote initialization, (3) runtime, (4) remote termination, (5) object deletion. Note that this is different from what the status outlet (second outlet of the \texttt{somax.server} object) shows: this outlet shows the different states as a result from the different phases. Figure \ref{fig:3-server-states} illustrates the relation between the phases and the states of the object. The state is continuously polled by the \texttt{somax.serverstatus} abstraction, which continuously sends requests over OSC to check whether the remote server is responding and update its status.

 \begin{figure}[h!]
    \centering        
 	\includegraphics[width=0.6\textwidth, keepaspectratio]{figures/server_state.png}
    \caption{State transition diagram for the \texttt{somax.server} object. The rounded rectangular objects represent the states as shown on the second outlet of the object and arrows indicate name of messages sent to the \texttt{somax.server} object (parenthesized text represent cases, not messages). Note that the diamond blocks do not necessarily represent conditions (for example the "remote termination" phase cannot meaningfully fail) they are only used to illustrate the different phases/transitions described in this text.} 
    \label{fig:3-server-states}
\end{figure}

%%%

\subsubsection{Object Initialization}
When the \texttt{somax.server} object is created, the strategy described in section \ref{ssec:3-abstractions} is used to handle \texttt{patcherargs} accordingly. There are three possible outcomes here:
\begin{itemize}
	\item The initialization fails because invalid arguments are provided (for example a port that is already in use\footnote{Note that while it's possible to initialize the server with custom ports and/or ip, it will not be possible to launch the server through the user interface in this case. To do this, the server must be manually launched from a terminal.}). The state will be \texttt{invalid} and the object will ignore all messages.
	\item The initialization fails because another \texttt{somax.server} already exists. The state will be \texttt{duplicate} and the object will ignore all messages except the \texttt{reload} message.
	\item The initialization succeeds. The state will be \texttt{offline} and accept any messages.
\end{itemize}

\noindent The reason why it's important for this step to be able to fail is because \texttt{somax.player} sends their \texttt{create\_agent} messages to the \texttt{somax.to\_server} address. If we have two initialized \texttt{somax.server} objects, this means that we will receive it twice and therefore create two duplicate remote agents, causing all sorts of issues. The same issue applies to all messages in general: even if we send a message directly on the inlet of one of two duplicate \texttt{somax.server} objects, we will only send a single message through the \texttt{udpsend}, but any response from the remote server will be received on both of the \texttt{udpreceive}, and hence risk causing a number of issues. The duplication status is handled through the internal \texttt{somax.num\_servers} \texttt{value} object mentioned in section \ref{ssec:3-global-state}, which is incremented when the object is created, independently of whether initialization succeeded or not. The ports used by the object are also stored in the \texttt{somax.recvports} dictionary.

Sending \texttt{reload} to a \texttt{somax.server} object will trigger the procedure described under "Object Deletion" immediately followed by the "Object Initialization"

All \texttt{loadbang}/\texttt{loadmess} messages are handled when the object is created (technically before the \texttt{patcherargs}, but this will only set the default values for a number of parameters and settings, it will not trigger any output, and the order that the \texttt{loadbang}s are executed in is (and should always be) irrelevant.

%%%

\subsubsection{Remote Initialization}
When the \texttt{initialize} message is sent to the \texttt{somax.server} (internally or externally â€“ the \texttt{autoinitialize} attribute will trigger the \texttt{initialize} message internally once object initialization is complete). When this is called, the remote server script/application will be launched through the \texttt{somax.interpreter}, specifically by using the \texttt{;max launchbrowser} command, which opens the provided file in the default application. Once the server has been properly launched, the \texttt{SomaxServer} will immediately send the message \texttt{initialized} over OSC, which will be output on the first outlet of the \texttt{somax.server} object, as well as send its currently stored value for all relevant attributes (currently only \texttt{tempo} and \texttt{active}).

%%%

\subsubsection{Runtime}
The runtime phase, from when the connection between the local \texttt{somax.server} and the remote \texttt{SomaxServer} has been established (represented by the states \texttt{playersmissing}, \texttt{ready} and \texttt{running}) is where the user likely spends 99\% of the time, but is from a development point of view the phase that requires the least amount of work. During this phase, any message sent to the \texttt{somax.server} object will simply be sent directly to the server (but stateful messages, such as \texttt{tempo} and \texttt{active} will also stored locally, in case the server is restarted).

During this phase, the \texttt{somax.serverstatus} will continuously poll the remote server, by sending a list of the names of all the local \texttt{somax.player} objects that exist in Max. The remote server will respond with two values, one boolean indicating whether all of these objects also exist on the remote (if not, the status will be \texttt{playersmissing}) and whether the server's transport is active (status: \texttt{running} or not (status: \texttt{ready}). Typically, the remote server should always be able to respond to these requests within a second, as all of its heavy operations are computed in separate threads, but in some cases (for example when running "Test Segmentation" from the \texttt{somax.audiocorpusbuilder}), the server will change its status to \texttt{working}, indicating that it didn't receive any response. If the server doesn't receive any response for 25 seconds, the \texttt{somax.serverstatus} will assume that the server has crashed and change the status to \texttt{terminated} (not represented in figure \ref{fig:3-server-states}).

%%%

\subsubsection{Remote Termination}
When an explicit \texttt{terminate} message is sent by the user, the remote server will be shut down and trigger the \texttt{terminated} message before closing. It will before shutting down delete all of its remote \texttt{OscAgent}s and thereby trigger \texttt{terminated} messages to all corresponding \texttt{somax.player}s. The \texttt{somax.serverstatus} will receive the \texttt{terminated} message and change its state to \texttt{terminated}. Note that this state is internally identical to \texttt{offline}.


%%%

\subsubsection{Object Deletion}
When the \texttt{somax.server} object deleted, the \texttt{freebang} is triggered, which decrements the \texttt{somax.num\_servers} \texttt{value} is decremented and its ports are deallocated from the  \texttt{somax.recvports} dictionary. If the \texttt{autoterminate} attribute is enabled (which is the default case), the remote server will also be shut down as if \texttt{terminate} was explicitly called\footnote{Note that this is not represented in figure \ref{fig:3-server-states}, but the object can obviously be deleted from any of the states above, so a direct transition from any state to the deletion phase is possible and non-problematic)}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PLAYER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{The Player Object}\label{ssec:3-player}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PERIPHERALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Peripherals}\label{ssec:3-peripherals}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Influencers}\label{ssec:3-influencers}
- why: cannot handle real-time audio in python

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Renderers}\label{ssec:3-renderers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Corpus Builders}\label{ssec:3-corpusbuilders}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{App Objects}\label{ssec:3-app-objects}
\todo{source/target}